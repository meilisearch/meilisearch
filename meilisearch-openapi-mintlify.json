{
  "openapi": "3.1.0",
  "info": {
    "title": "meilisearch",
    "description": "Meilisearch HTTP server",
    "contact": {
      "name": "Quentin de Quelen",
      "email": "quentin@dequelen.me"
    },
    "license": {
      "name": "MIT",
      "identifier": "MIT"
    },
    "version": "1.35.0"
  },
  "servers": [
    {
      "url": "http://localhost:7700",
      "description": "Local server"
    }
  ],
  "paths": {
    "/batches": {
      "get": {
        "tags": [
          "Async task management"
        ],
        "summary": "List batches",
        "description": "The `/batches` route gives information about the progress of batches of [asynchronous operations](/learn/async/asynchronous_operations).\n\nBatches are always returned in descending order of uid. This means that by default, the most recently created batch objects appear first. Batch results are paginated and can be filtered with query parameters.",
        "operationId": "get_batches",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of batches to return",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "`uid` of the first batch returned",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "If `true`, returns results in the reverse order, from oldest to most recent",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the\n`batchUids` query parameter is not set, all task uids are returned.\nIt's possible to specify several batch uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query\nparameter is not set, all task uids are returned. It's possible to\nspecify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them.\nIt's possible to specify several task uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types`\nquery parameter is not set, all task types are returned. It's possible\nto specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses`\nquery parameter is not set, all task statuses are returned. It's\npossible to specify several statuses by separating them with the `,`\ncharacter.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when\n`indexUids` query parameter is not set, the tasks of all the indexes\nare returned. It is possible to specify several indexes by separating\nthem with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batches",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllBatches"
                },
                "example": {
                  "results": [
                    {
                      "uid": 2,
                      "details": {
                        "stopWords": [
                          "of",
                          "the"
                        ]
                      },
                      "progress": null,
                      "stats": {
                        "totalNbTasks": 1,
                        "status": {
                          "succeeded": 1
                        },
                        "types": {
                          "settingsUpdate": 1
                        },
                        "indexUids": {
                          "INDEX_NAME": 1
                        }
                      },
                      "duration": "PT0.110083S",
                      "startedAt": "2024-12-10T15:49:04.995321Z",
                      "finishedAt": "2024-12-10T15:49:05.105404Z"
                    }
                  ],
                  "total": 1,
                  "limit": 20,
                  "from": 1,
                  "next": null
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'http://MEILISEARCH_URL/batches'"
          },
          {
            "lang": "JS",
            "source": "client.batches.getBatches();"
          },
          {
            "lang": "PHP",
            "source": "$client->getBatches();"
          },
          {
            "lang": "Python",
            "source": "client.get_batches()"
          },
          {
            "lang": "Ruby",
            "source": "client.batches"
          },
          {
            "lang": "Go",
            "source": "client.GetBatches();"
          },
          {
            "lang": "Rust",
            "source": "let mut query = meilisearch_sdk::batches::BatchesQuery::new(&client);\nquery.with_limit(20);\nlet batches: meilisearch_sdk::batches::BatchesResults =\n  client.get_batches_with(&query).await.unwrap();"
          }
        ]
      }
    },
    "/batches/{batchUid}": {
      "get": {
        "tags": [
          "Async task management"
        ],
        "summary": "Get batch",
        "description": "Get a single batch by its unique identifier.\n\nThe `/batches` route gives information about the progress of batches of [asynchronous operations](/learn/async/asynchronous_operations).",
        "operationId": "get_batch",
        "parameters": [
          {
            "name": "batchUid",
            "in": "path",
            "description": "The unique batch id",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "8685"
          }
        ],
        "responses": {
          "200": {
            "description": "Return the batch",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchView"
                },
                "example": {
                  "uid": 0,
                  "details": {
                    "receivedDocuments": 1,
                    "indexedDocuments": 1
                  },
                  "progress": null,
                  "stats": {
                    "totalNbTasks": 1,
                    "status": {
                      "succeeded": 1
                    },
                    "types": {
                      "documentAdditionOrUpdate": 1
                    },
                    "indexUids": {
                      "INDEX_NAME": 1
                    }
                  },
                  "duration": "PT0.364788S",
                  "startedAt": "2024-12-10T15:48:49.672141Z",
                  "finishedAt": "2024-12-10T15:48:50.036929Z",
                  "batchStrategy": "batched all enqueued tasks"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'http://MEILISEARCH_URL/batches/BATCH_UID'"
          },
          {
            "lang": "JS",
            "source": "client.batches.getBatch(BATCH_UID);"
          },
          {
            "lang": "PHP",
            "source": "$client->getBatch(BATCH_UID);"
          },
          {
            "lang": "Python",
            "source": "client.get_batch(BATCH_UID)"
          },
          {
            "lang": "Ruby",
            "source": "client.batch(BATCH_UID)"
          },
          {
            "lang": "Go",
            "source": "client.GetBatch(BATCH_UID);"
          },
          {
            "lang": "Rust",
            "source": "let uid: u32 = 42;\nlet batch: meilisearch_sdk::batches::Batch = client\n  .get_batch(uid)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/dumps": {
      "post": {
        "tags": [
          "Backups"
        ],
        "summary": "Create dump",
        "description": "Triggers a dump creation process. Once the process is complete, a dump is created in the\n[dump directory](https://www.meilisearch.com/docs/learn/self_hosted/configure_meilisearch_at_launch#dump-directory).\nIf the dump directory does not exist yet, it will be created.",
        "operationId": "create_dump",
        "responses": {
          "202": {
            "description": "Dump is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "dumpCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "dumps.create",
              "dumps.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/dumps'"
          },
          {
            "lang": "JS",
            "source": "client.createDump()"
          },
          {
            "lang": "PHP",
            "source": "$client->createDump();"
          },
          {
            "lang": "Python",
            "source": "client.create_dump()"
          },
          {
            "lang": "Java",
            "source": "client.createDump();"
          },
          {
            "lang": "Ruby",
            "source": "client.create_dump"
          },
          {
            "lang": "Go",
            "source": "resp, err := client.CreateDump()"
          },
          {
            "lang": "C#",
            "source": "await client.CreateDumpAsync();"
          },
          {
            "lang": "Rust",
            "source": "client\n  .create_dump()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.createDump();"
          },
          {
            "lang": "Swift",
            "source": "client.createDump { result in\n    switch result {\n    case .success(let dumpStatus):\n        print(dumpStatus)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/experimental-features": {
      "get": {
        "tags": [
          "Experimental features"
        ],
        "summary": "List experimental features",
        "description": "Get a list of all experimental features that can be activated via the\n/experimental-features route and whether or not they are currently\nactivated.",
        "operationId": "get_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.get",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/experimental-features/'"
          },
          {
            "lang": "Ruby",
            "source": "client.experimental_features"
          },
          {
            "lang": "Go",
            "source": "client.ExperimentalFeatures().Get()"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nlet res = features\n  .get()\n  .await\n  .unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Configure experimental features",
        "description": "Activate or deactivate experimental features.",
        "operationId": "patch_features",
        "responses": {
          "200": {
            "description": "Experimental features are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RuntimeTogglableFeatures"
                },
                "example": {
                  "metrics": true,
                  "logsRoute": false,
                  "editDocumentsByFunction": false,
                  "containsFilter": false,
                  "network": false,
                  "getTaskDocumentsRoute": false,
                  "compositeEmbedders": false,
                  "chatCompletions": false,
                  "multimodal": false,
                  "vectorStoreSetting": false
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "experimental_features.update",
              "experimental_features.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/experimental-features/' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '{\n    \"metrics\": true\n  }'"
          },
          {
            "lang": "Ruby",
            "source": "client.update_experimental_features(metrics: true)"
          },
          {
            "lang": "Go",
            "source": "client.ExperimentalFeatures().SetMetrics(true).Update()"
          },
          {
            "lang": "Rust",
            "source": "let client = Client::new(\"http://localhost:7700\", Some(\"apiKey\"));\nlet features = ExperimentalFeatures::new(&client);\nfeatures.set_metrics(true)\nlet res = features\n  .update()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/export": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Export to a remote Meilisearch",
        "description": "Triggers an export process to a remote Meilisearch instance. This allows you to send\ndocuments and settings from the current instance to another Meilisearch server.",
        "operationId": "export",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Export"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Export successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 1,
                  "status": "enqueued",
                  "type": "export",
                  "enqueuedAt": "2021-08-11T09:25:53.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "export",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/export' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"TARGET_INSTANCE_URL\",\n    \"indexes\": {\n      \"*\": {\n        \"overrideSettings\": true\n      }\n    }\n  }'"
          },
          {
            "lang": "Java",
            "source": "Map<String, ExportIndexFilter> indexes = new HashMap<>();\nindexes.put(\"*\", ExportIndexFilter.builder().overrideSettings(true).build());\nExportRequest request = ExportRequest.builder().url(\"TARGET_INSTANCE_URL\").indexes(indexes).build();\nclient.export(request);"
          }
        ]
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Health"
        ],
        "summary": "Get health",
        "description": "The health check endpoint enables you to periodically test the health of\nyour Meilisearch instance.",
        "operationId": "get_health",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthResponse"
                },
                "example": {
                  "status": "available"
                }
              }
            }
          }
        },
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/health'"
          },
          {
            "lang": "JS",
            "source": "client.health()"
          },
          {
            "lang": "PHP",
            "source": "$client->health();"
          },
          {
            "lang": "Python",
            "source": "client.health()"
          },
          {
            "lang": "Java",
            "source": "client.health();"
          },
          {
            "lang": "Ruby",
            "source": "client.health"
          },
          {
            "lang": "Go",
            "source": "client.Health()"
          },
          {
            "lang": "C#",
            "source": "await client.HealthAsync();"
          },
          {
            "lang": "Rust",
            "source": "// health() return an Err() if the server is not healthy, so this example would panic due to the unwrap\nclient\n  .health()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.health();"
          },
          {
            "lang": "Swift",
            "source": "client.health { (result) in\n    switch result {\n    case .success:\n        print(\"Healthy!\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "List indexes",
        "description": "List all indexes.",
        "operationId": "list_indexes",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "description": "The number of indexes to skip before starting to retrieve anything",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            },
            "example": 100
          },
          {
            "name": "limit",
            "in": "query",
            "description": "The number of indexes to retrieve",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            },
            "example": 1
          }
        ],
        "responses": {
          "200": {
            "description": "Indexes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_IndexView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "movies",
                      "primaryKey": "movie_id",
                      "createdAt": "2019-11-20T09:40:33.711324Z",
                      "updatedAt": "2019-11-20T09:40:33.711324Z"
                    }
                  ],
                  "limit": 1,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes?limit=3'"
          },
          {
            "lang": "JS",
            "source": "client.getIndexes({ limit: 3 })"
          },
          {
            "lang": "PHP",
            "source": "$client->getIndexes((new IndexesQuery())->setLimit(3));"
          },
          {
            "lang": "Python",
            "source": "client.get_indexes({'limit': 3})"
          },
          {
            "lang": "Java",
            "source": "IndexesQuery query = new IndexesQuery().setLimit(3);\nclient.getIndexes(query);"
          },
          {
            "lang": "Ruby",
            "source": "client.indexes(limit: 3)"
          },
          {
            "lang": "Go",
            "source": "client.GetIndexes(&meilisearch.IndexesQuery{\n  Limit: 3,\n})"
          },
          {
            "lang": "C#",
            "source": "await client.GetAllIndexesAsync(new IndexesQuery { Limit = 3 });"
          },
          {
            "lang": "Rust",
            "source": "let mut indexes = IndexesQuery::new(&client)\n  .with_limit(3)\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getIndexes(params: IndexesQuery(limit: 3));"
          },
          {
            "lang": "Swift",
            "source": "client.getIndexes { (result) in\n    switch result {\n    case .success(let indexes):\n        print(indexes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create index",
        "description": "Create an index.",
        "operationId": "create_index",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/IndexCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexCreation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.create",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"uid\": \"movies\",\n    \"primaryKey\": \"id\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.createIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "PHP",
            "source": "$client->createIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "Python",
            "source": "client.create_index('movies', {'primaryKey': 'id'})"
          },
          {
            "lang": "Java",
            "source": "client.createIndex(\"movies\", \"id\");"
          },
          {
            "lang": "Ruby",
            "source": "client.create_index('movies', primary_key: 'id')"
          },
          {
            "lang": "Go",
            "source": "client.CreateIndex(&meilisearch.IndexConfig{\n  Uid: \"movies\",\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.CreateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "Rust",
            "source": "client.create_index(\"movies\", Some(\"id\"))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.createIndex('movies', primaryKey: 'id');"
          },
          {
            "lang": "Swift",
            "source": "client.createIndex(uid: \"movies\", primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "Get index",
        "description": "Get information about an index.",
        "operationId": "get_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The index is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexView"
                },
                "example": {
                  "uid": "movies",
                  "primaryKey": "movie_id",
                  "createdAt": "2019-11-20T09:40:33.711324Z",
                  "updatedAt": "2019-11-20T09:40:33.711324Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.get",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getRawInfo()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->fetchRawInfo();"
          },
          {
            "lang": "Python",
            "source": "client.get_index('movies')"
          },
          {
            "lang": "Java",
            "source": "client.getIndex(\"movies\");"
          },
          {
            "lang": "Ruby",
            "source": "client.fetch_index('movies')"
          },
          {
            "lang": "Go",
            "source": "client.GetIndex(\"movies\")"
          },
          {
            "lang": "C#",
            "source": "await client.GetIndexAsync(\"movies\");"
          },
          {
            "lang": "Rust",
            "source": "let movies: Index = client\n  .get_index(\"movies\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getIndex('movies');"
          },
          {
            "lang": "Swift",
            "source": "client.getIndex(\"movies\") { (result) in\n    switch result {\n    case .success(let index):\n        print(index)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Indexes"
        ],
        "summary": "Delete index",
        "description": "Delete an index.",
        "operationId": "delete_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexDeletion",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.delete",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies'"
          },
          {
            "lang": "JS",
            "source": "client.deleteIndex('movies')"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteIndex('movies');"
          },
          {
            "lang": "Python",
            "source": "client.delete_index('movies')\n// OR\nclient.index('movies').delete()"
          },
          {
            "lang": "Java",
            "source": "client.deleteIndex(\"movies\");"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_index('movies')"
          },
          {
            "lang": "Go",
            "source": "client.DeleteIndex(\"movies\")\n// OR\nclient.Index(\"movies\").Delete()"
          },
          {
            "lang": "C#",
            "source": "await client.DeleteIndexAsync(\"movies\");"
          },
          {
            "lang": "Rust",
            "source": "client.index(\"movies\")\n  .delete()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').delete();\nt_one_document_1: \"await client.index('movies').getDocument(25684,\\n    fields: ['id', 'title', 'poster', 'release_date']);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").delete { (result) in\n    switch result {\n    case .success:\n        print(\"Index deleted\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "patch": {
        "tags": [
          "Indexes"
        ],
        "summary": "Update index",
        "description": "Update the `primaryKey` of an index.\nReturn an error if the index doesn't exists yet or if it contains\ndocuments.",
        "operationId": "update_index",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateIndexRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "indexUpdate",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "indexes.update",
              "indexes.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"primaryKey\": \"id\" }'"
          },
          {
            "lang": "JS",
            "source": "client.updateIndex('movies', { primaryKey: 'id' })"
          },
          {
            "lang": "PHP",
            "source": "$client->updateIndex('movies', ['primaryKey' => 'id']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update(primary_key='id')"
          },
          {
            "lang": "Java",
            "source": "client.updateIndex(\"movies\", \"id\");"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update(primary_key: 'movie_id')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateIndex(&meilisearch.UpdateIndexRequestParams{\n  PrimaryKey: \"id\",\n})"
          },
          {
            "lang": "C#",
            "source": "TaskInfo task = await client.UpdateIndexAsync(\"movies\", \"id\");"
          },
          {
            "lang": "Rust",
            "source": "let task = IndexUpdater::new(\"movies\", &client)\n  .with_primary_key(\"movie_review_id\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').update(primaryKey: 'id');"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").update(primaryKey: \"id\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/compact": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Compact index",
        "description": "Triggers a compaction process on the specified index. Compaction reorganizes the index database to make it smaller and more efficient.",
        "operationId": "compact",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_UID/compact'"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->compact();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').compact()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").compact();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').compact"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"INDEX_UID\").Compact();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"INDEX_UID\")\n  .compact()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "List documents with GET",
        "description": "Get documents by batches.",
        "operationId": "get_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of documents to skip in the response. Use this parameter\ntogether with `limit` to paginate through large document sets. For\nexample, to get documents 21-40, set `offset=20` and `limit=20`.\nDefaults to `0`.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of documents to return in a single response. Use\ntogether with `offset` for pagination. Defaults to `20`.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "fields",
            "in": "query",
            "description": "Comma-separated list of document attributes to include in the\nresponse. Use `*` to retrieve all attributes. By default, all\nattributes are returned. Example: `title,description,price`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "description": "When `true`, includes vector embeddings in the response for documents\nthat have them. This is useful when you need to inspect or export\nvector data. Defaults to `false`.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ids",
            "in": "query",
            "description": "Comma-separated list of document IDs to retrieve. Only documents with\nmatching IDs will be returned. If not specified, all documents\nmatching other criteria are returned.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "Filter expression to select which documents to return. Uses the same\nsyntax as search filters. Only documents matching the filter will be\nincluded in the response. Example: `genres = action AND rating > 4`.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "popularity > 1000"
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Attribute(s) to sort the documents by. Format: `attribute:asc` or\n`attribute:desc`. Multiple sort criteria can be comma-separated.\nExample: `price:asc,rating:desc`.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "id": 25684,
                      "title": "American Ninja 5",
                      "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                      "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                      "release_date": 725846400
                    },
                    {
                      "id": 45881,
                      "title": "The Bridge of San Luis Rey",
                      "poster": "https://image.tmdb.org/t/p/w500/4X7quIcdkc24Cveg5XdpfRqxtYA.jpg",
                      "overview": "The Bridge of San Luis Rey is American author Thornton Wilder's second novel, first published in 1927 to worldwide acclaim. It tells the story of several interrelated people who die in the collapse of an Inca rope-fiber suspension bridge in Peru, and the events that lead up to their being on the bridge.[ A friar who has witnessed the tragic accident then goes about inquiring into the lives of the victims, seeking some sort of cosmic answer to the question of why each had to die. The novel won the Pulitzer Prize in 1928.",
                      "release_date": 1072915200
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 2
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents?limit=2&filter=genres=action'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getDocuments({\n  limit: 2,\n  filter: 'genres = action',\n  sort: ['release_date:desc']\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDocuments((new DocumentsQuery())->setFilter('genres = action')->setLimit(2));"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_documents({\n  'limit':2, 'filter': 'genres=action',\n  'sort': ['rating:desc', 'release_date:asc']  # list format\n})"
          },
          {
            "lang": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery().setLimit(2).setFilter(new String[] {\"genres = action\"});\nclient.index(\"movies\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').get_documents(limit: 2, filter: 'genres = action')"
          },
          {
            "lang": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"movies\").GetDocuments(&meilisearch.DocumentsQuery{\n  Limit: 2,\n  Filter: \"genres = action\",\n}, &result)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() { Limit = 2, Filter = \"genres = action\" });"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"movies\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"genres = action\")\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDocuments(params: DocumentsQuery(limit: 2)) { (result: Result<DocumentsResults<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let movies):\n        print(movies)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or update documents",
        "description": "Add a list of documents or update them if they already exist.\nIf you send an already existing document (same id) the old document will\nbe only partially updated according to the fields of the new document.\nThus, any fields not present in the new document are kept and remained\nunchanged.\nTo completely overwrite a document, see Add or replace documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document.\n> `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved\n> `_vectors` field in your documents. It can accept an array of floats,\n> multiple arrays of floats in an outer array or an object. This object\n> accepts keys corresponding to the different embedders defined your index\n> settings.",
        "operationId": "update_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want\nto set the primary key of your index through this route, it only has\nto be done the first time you add documents to the index. After which\nit will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "description": "A string that can be used to identify and filter tasks. This metadata\nis stored with the task and returned in task responses. Useful for\ntracking tasks from external systems or associating tasks with\nspecific operations in your application.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          },
          {
            "name": "skipCreation",
            "in": "query",
            "description": "When set to `true`, only updates existing documents and skips creating\nnew ones. Documents that don't already exist in the index will be\nignored. This is useful for partial updates where you only want to\nmodify existing records without adding new ones.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam \",\n      \"genres\": \"comedy\"\n    }\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDocuments([{\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n}])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam ',\n    'genres' => 'comedy'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_documents([{\n    'id': 287947,\n    'title': 'Shazam ',\n    'genres': 'comedy'\n}], skip_creation=True)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateDocuments(\"[{\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam \\\",\"\n  + \"\\\"genres\\\": \\\"comedy\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_documents([\n  {\n    id: 287947,\n    title: 'Shazam ',\n    genres: 'comedy'\n  }\n])"
          },
          {
            "lang": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":     287947,\n    \"title\":  \"Shazam \",\n    \"genres\": \"comedy\",\n  },\n}\noptions := &meilisearch.DocumentOptions{SkipCreation: true}\nclient.Index(\"movies\").UpdateDocuments(documents, options)"
          },
          {
            "lang": "C#",
            "source": "var movie = new[]\n{\n    new Movie { Id = \"287947\", Title = \"Shazam \", Genres = \"comedy\" }\n};\nawait index.UpdateDocumentsAsync(movie);"
          },
          {
            "lang": "Rust",
            "source": "// Define the type of our documents\n#[derive(Serialize, Deserialize)]\nstruct IncompleteMovie {\n  id: usize,\n  title: String,\n  genres: String\n}\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_update(&[\n    IncompleteMovie {\n      id: 287947,\n      title: \"Shazam \".to_string(),\n      genres: \"comedy\".to_string()\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam \",\n    \"genres\": \"comedy\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").updateDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Add or replace documents",
        "description": "Add a list of documents or replace them if they already exist.\n\nIf you send an already existing document (same id) the whole existing\ndocument will be overwritten by the new document. Fields previously in the\ndocument not present in the new document are removed.\n\nFor a partial update of the document see Add or update documents route.\n> info\n> If the provided index does not exist, it will be created.\n> info\n> Use the reserved `_geo` object to add geo coordinates to a document.\n> `_geo` is an object made of `lat` and `lng` field.\n>\n> When the vectorStore feature is enabled you can use the reserved\n> `_vectors` field in your documents. It can accept an array of floats,\n> multiple arrays of floats in an outer array or an object. This object\n> accepts keys corresponding to the different embedders defined your index\n> settings.",
        "operationId": "replace_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "primaryKey",
            "in": "query",
            "description": "The primary key of the documents. primaryKey is optional. If you want\nto set the primary key of your index through this route, it only has\nto be done the first time you add documents to the index. After which\nit will be ignored if given.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "id"
          },
          {
            "name": "csvDelimiter",
            "in": "query",
            "description": "Customize the csv delimiter when importing CSV documents.",
            "required": true,
            "schema": {
              "type": "string",
              "default": ","
            },
            "example": ";"
          },
          {
            "name": "customMetadata",
            "in": "query",
            "description": "A string that can be used to identify and filter tasks. This metadata\nis stored with the task and returned in task responses. Useful for\ntracking tasks from external systems or associating tasks with\nspecific operations in your application.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "custom"
          },
          {
            "name": "skipCreation",
            "in": "query",
            "description": "When set to `true`, only updates existing documents and skips creating\nnew ones. Documents that don't already exist in the index will be\nignored. This is useful for partial updates where you only want to\nmodify existing records without adding new ones.",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {}
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.add",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"id\": 287947,\n      \"title\": \"Shazam\",\n      \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n      \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n      \"release_date\": \"2019-03-23\"\n    }\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').addDocuments([{\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n}])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->addDocuments([\n  [\n    'id' => 287947,\n    'title' => 'Shazam',\n    'poster' => 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview' => 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date' => '2019-03-23'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').add_documents([{\n  'id': 287947,\n  'title': 'Shazam',\n  'poster': 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n  'overview': 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n  'release_date': '2019-03-23'\n}], skip_creation=True)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").addDocuments(\"[{\"\n  + \"\\\"id\\\": 287947,\"\n  + \"\\\"title\\\": \\\"Shazam\\\",\"\n  + \"\\\"poster\\\": \\\"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\\\",\"\n  + \"\\\"overview\\\": \\\"A boy is given the ability to become an adult superhero in times of need with a single magic word.\\\",\"\n  + \"\\\"release_date\\\": \\\"2019-03-23\\\"\"\n  + \"}]\"\n);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').add_documents([\n  {\n    id: 287947,\n    title: 'Shazam',\n    poster: 'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    overview: 'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    release_date: '2019-03-23'\n  }\n])"
          },
          {
            "lang": "Go",
            "source": "documents := []map[string]interface{}{\n  {\n    \"id\":           287947,\n    \"title\":        \"Shazam\",\n    \"poster\":       \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\":     \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\",\n  },\n}\noptions := &meilisearch.DocumentOptions{SkipCreation: false}\nclient.Index(\"movies\").AddDocuments(documents, options)"
          },
          {
            "lang": "C#",
            "source": "var movie = new[]\n{\n    new Movie\n    {\n          Id = \"287947\",\n          Title = \"Shazam\",\n          Poster = \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n          Overview = \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n          ReleaseDate = \"2019-03-23\"\n    }\n};\nawait index.AddDocumentsAsync(movie);"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .add_or_replace(&[\n    Movie {\n      id: 287947,\n      title: \"Shazam\".to_string(),\n      poster: \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\".to_string(),\n      overview: \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\".to_string(),\n      release_date: \"2019-03-23\".to_string(),\n    }\n  ], None)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').addDocuments([\n  {\n    'id': 287947,\n    'title': 'Shazam',\n    'poster':\n        'https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg',\n    'overview':\n        'A boy is given the ability to become an adult superhero in times of need with a single magic word.',\n    'release_date': '2019-03-23'\n  }\n]);\nd_or_update_documents_1: \"await client.index('movies').updateDocuments([\\n  {\\n    'id': 287947,\\n    'title': 'Shazam ',\\n    'genres': 'comedy',\\n  }\\n]);\""
          },
          {
            "lang": "Swift",
            "source": "let documentJsonString = \"\"\"\n[\n  {\n    \"reference_number\": 287947,\n    \"title\": \"Shazam\",\n    \"poster\": \"https://image.tmdb.org/t/p/w1280/xnopI5Xtky18MPhK40cZAGAOVeV.jpg\",\n    \"overview\": \"A boy is given the ability to become an adult superhero in times of need with a single magic word.\",\n    \"release_date\": \"2019-03-23\"\n  }\n]\n\"\"\"\nlet documents: Data = documentJsonString.data(using: .utf8)!\n\nclient.index(\"movies\").addDocuments(documents: documents) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete all documents",
        "description": "Delete all documents in the specified index.",
        "operationId": "clear_all_documents",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/documents'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteAllDocuments()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteAllDocuments();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_all_documents()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").deleteAllDocuments();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_all_documents"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteAllDocuments()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteAllDocumentsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_all_documents()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').deleteAllDocuments();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").deleteAllDocuments() { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by filter",
        "description": "Delete a set of documents based on a filter.",
        "operationId": "delete_documents_by_filter",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentDeletionByFilter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/movies/documents/delete \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"genres = action OR genres = adventure\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteDocuments({\n  filter: 'genres = action OR genres = adventure'\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteDocuments(['filter' => 'genres = action OR genres = adventure']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_documents(filter='genres=action OR genres=adventure')"
          },
          {
            "lang": "Java",
            "source": "String filter = \"genres = action OR genres = adventure\";\nclient.index(\"movies\").deleteDocumentsByFilter(filter);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_documents(filter: 'genres = action OR genres = adventure')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteDocumentsByFilter(\"genres=action OR genres=adventure\")"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new DeleteDocumentsQuery() { Filter = \"genres = action OR genres = adventure\" });"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"movies\");\nlet task = DocumentDeletionQuery::new(&index)\n  .with_filter(\"genres = action OR genres = adventure\")\n  .execute()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/delete-batch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete documents by batch",
        "description": "Delete a set of documents based on an array of document ids.",
        "operationId": "delete_documents_batch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {}
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents/delete-batch' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    23488,\n    153738,\n    437035,\n    363869\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteDocuments([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteDocuments([23488, 153738, 437035, 363869]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").deleteDocuments(Arrays.asList(new String[]\n{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\"\n}));"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_documents([23488, 153738, 437035, 363869])"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteDocuments([]string{\n  \"23488\",\n  \"153738\",\n  \"437035\",\n  \"363869\",\n})"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteDocumentsAsync(new[] { \"23488\", \"153738\", \"437035\", \"363869\" });"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_documents(&[23488, 153738, 437035, 363869])\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/edit": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Edit documents by function",
        "description": "Use a [RHAI function](https://rhai.rs/book/engine/hello-world.html) to\nedit one or more documents directly in Meilisearch.",
        "operationId": "edit_documents_by_function",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentEditionByFunction"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/documents/edit' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"function\": \"doc.new_field = `a]new[value`\",\n    \"filter\": \"id > 3000\",\n    \"context\": {\n      \"max_title_length\": 10\n    }\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/fetch": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "List documents with POST",
        "description": "Get a set of documents.",
        "operationId": "documents_by_query_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BrowseQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Value"
                },
                "example": {
                  "results": [
                    {
                      "title": "The Travels of Ibn Battuta",
                      "genres": [
                        "Travel",
                        "Adventure"
                      ],
                      "language": "English",
                      "rating": 4.5
                    },
                    {
                      "title": "Pride and Prejudice",
                      "genres": [
                        "Classics",
                        "Fiction",
                        "Romance",
                        "Literature"
                      ],
                      "language": "English",
                      "rating": 4
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "total": 5
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/indexes/books/documents/fetch \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"filter\": \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n    \"fields\": [\"title\", \"genres\", \"rating\", \"language\"],\n    \"limit\": 3\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getDocuments({\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  fields: ['title', 'genres', 'rating', 'language'],\n  limit: 3,\n  sort: ['release_date:desc']\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getDocuments(\n  (new DocumentsQuery())\n    ->setFilter('(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English')\n    ->setLimit(3)\n    ->setFields(['title', 'genres', 'rating', 'language'])\n);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_documents({\n  'limit':3,\n  'fields': ['title', 'genres', 'rating', 'language'],\n  'filter': '(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English',\n  'sort': 'rating:desc, title:asc'  # comma-separated string format\n})"
          },
          {
            "lang": "Java",
            "source": "DocumentsQuery query = new DocumentsQuery()\n  .setFilter(new String[] {\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\"})\n  .setFields(new String[] {\"title\", \"genres\", \"rating\", \"language\"})\n  .setLimit(3);\nclient.index(\"books\").getDocuments(query, TargetClassName.class);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').get_documents(\n  filter: '(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English',\n  limit: 3,\n  fields: ['title', 'genres', 'rating', 'language']\n)"
          },
          {
            "lang": "Go",
            "source": "var result meilisearch.DocumentsResult\n\nclient.Index(\"books\").GetDocuments(&meilisearch.DocumentsQuery{\n  Fields: []string{\"title\", \"genres\", \"rating\", \"language\"},\n  Filter: \"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\",\n}, &result)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentsAsync<Movie>(new DocumentsQuery() {\n    Limit = 3,\n    Fields = new List<string> { \"title\", \"genres\", \"rating\", \"language\"},\n    Filter = \"(rating > 3 AND (genres=Adventure OR genres=Fiction)) AND language=English\"\n});"
          },
          {
            "lang": "Rust",
            "source": "let index = client.index(\"books\");\nlet documents: DocumentsResults = DocumentsQuery::new(&index)\n  .with_filter(\"(rating > 3 AND (genres = Adventure OR genres = Fiction)) AND language = English\")\n  .with_fields([\"title\", \"genres\", \"rating\", \"language\"])\n  .with_limit(2)\n  .execute::<Movies>()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/documents/{documentId}": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Get document",
        "description": "Get one document from its primary key.",
        "operationId": "get_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "The document identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "85087"
          },
          {
            "name": "fields",
            "in": "query",
            "description": "Comma-separated list of document attributes to include in the\nresponse. Use `*` to retrieve all attributes. By default, all\nattributes listed in the `displayedAttributes` setting are returned.\nExample: `title,description,price`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "description": "When `true`, includes the vector embeddings in the response for this\ndocument. This is useful when you need to inspect or export vector\ndata. Note that this can significantly increase response size if the\ndocument has multiple embedders configured. Defaults to `false`.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The document is returned",
            "content": {
              "application/json": {
                "schema": {},
                "example": {
                  "id": 25684,
                  "title": "American Ninja 5",
                  "poster": "https://image.tmdb.org/t/p/w1280/iuAQVI4mvjI83wnirpD8GVNRVuY.jpg",
                  "overview": "When a scientists daughter is kidnapped, American Ninja, attempts to find her, but this time he teams up with a youngster he has trained in the ways of the ninja.",
                  "release_date": 725846400
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Document not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Document `a` not found.",
                  "code": "document_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#document_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.get",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/documents/25684?fields=id,title,poster,release_date'"
          },
          {
            "lang": "JS",
            "source": "client\n    .index('movies')\n    .getDocument(25684, { fields: ['id', 'title', 'poster', 'release_date'] })"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDocument(25684, ['id', 'title', 'poster', 'release_date']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_document(25684, {\n  'fields': ['id', 'title', 'poster', 'release_date']\n})"
          },
          {
            "lang": "Java",
            "source": "DocumentQuery query = new DocumentQuery().setFields(new String[] {\"id\", \"title\", \"poster\", \"release_date\"});\nclient.index(\"movies\").getDocument(\"25684\", query);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').document(25684, fields: ['id', 'title', 'poster', 'release_date'])"
          },
          {
            "lang": "Go",
            "source": "var a interface{}\nclient.Index(\"movies\").GetDocument(\"25684\",&meilisearch.DocumentQuery{\n  Fields: []string{\"id\", \"title\", \"poster\", \"release_date\"},\n}, &a)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDocumentAsync<Movie>(25684, new List<string> { \"id\", \"title\", \"poster\", \"release_date\" });"
          },
          {
            "lang": "Rust",
            "source": "let index = client\n  .index(\"movies\");\nlet document = DocumentQuery::new(&index)\n  .with_fields([\"id\", \"title\", \"poster\", \"release_date\"])\n  .execute::<Movie>(\"25684\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDocument(25684) { (result: Result<Movie, Swift.Error>) in\n    switch result {\n    case .success(let movie):\n        print(movie)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Delete document",
        "description": "Delete a single document by id.",
        "operationId": "delete_document",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "documentId",
            "in": "path",
            "description": "Document Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "853"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "documentAdditionOrUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "documents.delete",
              "documents.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/documents/25684'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').deleteDocument(25684)"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->deleteDocument(25684);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').delete_document(25684)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").deleteDocument(\"25684\");"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').delete_document(25684)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").DeleteDocument(\"25684\")"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").DeleteOneDocumentAsync(\"25684\");"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .delete_document(25684)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').deleteDocument(25684);\nlete_documents_by_batch_1: \"await client.index('movies').deleteDocuments(\\n      DeleteDocumentsQuery(\\n        ids: [23488, 153738, 437035, 363869],\\n      ),\\n    );\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").deleteDocument(\"25684\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/facet-search": {
      "post": {
        "tags": [
          "Facet Search"
        ],
        "summary": "Search in facets",
        "description": "Search for a facet value within a given facet.",
        "operationId": "search",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetSearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/books/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"facetQuery\": \"fiction\",\n    \"facetName\": \"genres\",\n    \"filter\": \"rating > 3\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').searchForFacetValues({\n  facetQuery: 'fiction',\n  facetName: 'genres'\n  filter: 'rating > 3'\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->facetSearch(\n  (new FacetSearchQuery())\n      ->setFacetQuery('fiction')\n      ->setFacetName('genres')\n      ->setFilter(['rating > 3'])\n);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').facet_search('genres', 'fiction', {\n  'filter': 'rating > 3'\n})"
          },
          {
            "lang": "Java",
            "source": "FacetSearchRequest fsr = FacetSearchRequest.builder().facetName(\"genres\").facetQuery(\"fiction\").filter(new String[]{\"rating > 3\"}).build();\nclient.index(\"books\").facetSearch(fsr);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').facet_search('genres', 'fiction', filter: 'rating > 3')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").FacetSearch(&meilisearch.FacetSearchRequest{\n  FacetQuery: \"fiction\",\n  FacetName: \"genres\",\n  Filter: \"rating > 3\",\n})"
          },
          {
            "lang": "C#",
            "source": "var query = new SearchFacetsQuery()\n{\n  FacetQuery = \"fiction\",\n  Filter = \"rating > 3\"\n};\nawait client.Index(\"books\").FacetSearchAsync(\"genres\", query);"
          },
          {
            "lang": "Rust",
            "source": "let res = client.index(\"books\")\n  .facet_search(\"genres\")\n  .with_facet_query(\"fiction\")\n  .with_filter(\"rating > 3\")\n  .execute()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/fields": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "List index fields",
        "description": "Returns a paginated list of fields in the index with their metadata: whether they are displayed, searchable, sortable, filterable, distinct, have a custom ranking rule (asc/desc), and for filterable fields the sort order for facet values.",
        "operationId": "post_index_fields",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Unique identifier of the index whose fields to list",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "description": "Pagination (offset, limit) and optional filter to restrict which fields are returned.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListFields"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_Field"
                },
                "example": {
                  "results": [
                    {
                      "name": "title",
                      "displayed": {
                        "enabled": true
                      },
                      "searchable": {
                        "enabled": true
                      },
                      "sortable": {
                        "enabled": true
                      },
                      "distinct": {
                        "enabled": false
                      },
                      "rankingRule": {
                        "enabled": false,
                        "order": null
                      },
                      "filterable": {
                        "enabled": false,
                        "sortBy": "count",
                        "facetSearch": false,
                        "equality": false,
                        "comparison": false
                      },
                      "localized": {
                        "locales": []
                      }
                    },
                    {
                      "name": "genre",
                      "displayed": {
                        "enabled": true
                      },
                      "searchable": {
                        "enabled": false
                      },
                      "sortable": {
                        "enabled": false
                      },
                      "distinct": {
                        "enabled": false
                      },
                      "rankingRule": {
                        "enabled": false,
                        "order": null
                      },
                      "filterable": {
                        "enabled": true,
                        "sortBy": "alpha",
                        "facetSearch": true,
                        "equality": true,
                        "comparison": false
                      },
                      "localized": {
                        "locales": []
                      }
                    }
                  ],
                  "offset": 0,
                  "limit": 20,
                  "total": 2
                }
              }
            }
          },
          "401": {
            "description": "Missing or invalid authorization header",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "fields.post",
              "fields.*",
              "*"
            ]
          }
        ]
      }
    },
    "/indexes/{indexUid}/search": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Search with GET",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_url_query",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "q",
            "in": "query",
            "description": "The search query string. Meilisearch will return documents that match\nthis query. Supports prefix search (words matching the beginning of\nthe query) and typo tolerance. Leave empty to match all documents.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "vector",
            "in": "query",
            "description": "A vector of floating-point numbers for semantic/vector search. The\ndimensions must match the embedder configuration. When provided,\ndocuments are ranked by vector similarity. Can be combined with `q`\nfor hybrid search.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            },
            "explode": false
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of search results to skip. Use together with `limit` for\npagination. For example, to get results 21-40, set `offset=20` and\n`limit=20`. Defaults to `0`. Cannot be used with `page`/`hitsPerPage`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of search results to return. Use together with `offset`\nfor pagination. Defaults to `20`. Cannot be used with\n`page`/`hitsPerPage`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "Request a specific page of results (1-indexed). Use together with\n`hitsPerPage` for page-based pagination. Cannot be used with\n`offset`/`limit`.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "hitsPerPage",
            "in": "query",
            "description": "Number of results per page when using page-based pagination. Use\ntogether with `page`. Cannot be used with `offset`/`limit`.",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0
            }
          },
          {
            "name": "attributesToRetrieve",
            "in": "query",
            "description": "Comma-separated list of attributes to include in the returned\ndocuments. Use `*` to return all attributes. By default, returns\nattributes from the `displayedAttributes` setting.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "retrieveVectors",
            "in": "query",
            "description": "When `true`, includes vector embeddings in the response for documents\nthat have them. Defaults to `false`.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "attributesToCrop",
            "in": "query",
            "description": "Comma-separated list of attributes whose values should be cropped to\nfit within `cropLength`. Useful for displaying long text attributes\nin search results. Format: `attribute` or `attribute:length`.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "cropLength",
            "in": "query",
            "description": "Maximum number of words to keep when cropping attribute values. The\ncropped text will be centered around the matching terms. Defaults to\n`10`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 10,
              "minimum": 0
            }
          },
          {
            "name": "attributesToHighlight",
            "in": "query",
            "description": "Comma-separated list of attributes whose matching terms should be\nhighlighted with `highlightPreTag` and `highlightPostTag`. Use `*` to\nhighlight all searchable attributes.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "filter",
            "in": "query",
            "description": "Filter expression to narrow down search results. Uses SQL-like syntax.\nExample: `genres = action AND rating > 4`. Only attributes in\n`filterableAttributes` can be used.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Comma-separated list of attributes to sort by. Format: `attribute:asc`\nor `attribute:desc`. Only attributes in `sortableAttributes` can be\nused. Custom ranking rules can also affect sort order.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "distinct",
            "in": "query",
            "description": "Attribute used to ensure only one document with each unique value is\nreturned. Useful for deduplication. Only attributes in\n`filterableAttributes` can be used.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "showMatchesPosition",
            "in": "query",
            "description": "When `true`, returns the position (start and length) of each matched\nterm in the original document attributes. Useful for custom\nhighlighting implementations.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScore",
            "in": "query",
            "description": "When `true`, includes a `_rankingScore` field (0.0 to 1.0) in each\ndocument indicating how well it matches the query. Higher scores mean\nbetter matches.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showRankingScoreDetails",
            "in": "query",
            "description": "When `true`, includes a `_rankingScoreDetails` object showing the\ncontribution of each ranking rule to the final score. Useful for\ndebugging relevancy.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "showPerformanceDetails",
            "in": "query",
            "description": "When `true`, includes a `_performanceDetails` object showing the\nperformance details of the search.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "facets",
            "in": "query",
            "description": "Comma-separated list of attributes for which to return facet\ndistribution (value counts). Only attributes in `filterableAttributes`\ncan be used. Returns the count of documents matching each facet value.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "highlightPreTag",
            "in": "query",
            "description": "HTML tag or string to insert before highlighted matching terms.\nDefaults to `<em>`.",
            "required": true,
            "schema": {
              "type": "string",
              "default": "<em>"
            }
          },
          {
            "name": "highlightPostTag",
            "in": "query",
            "description": "HTML tag or string to insert after highlighted matching terms.\nDefaults to `</em>`.",
            "required": true,
            "schema": {
              "type": "string",
              "default": "</em>"
            }
          },
          {
            "name": "cropMarker",
            "in": "query",
            "description": "String used to indicate truncated content when cropping. Defaults to\n`` (ellipsis).",
            "required": true,
            "schema": {
              "type": "string",
              "default": ""
            }
          },
          {
            "name": "matchingStrategy",
            "in": "query",
            "description": "Strategy for matching query terms. `last` (default): all terms must\nmatch, removing terms from the end if needed. `all`: all terms must\nmatch exactly. `frequency`: prioritizes matching frequent terms.",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/MatchingStrategy"
            }
          },
          {
            "name": "attributesToSearchOn",
            "in": "query",
            "description": "Comma-separated list of attributes to search in. By default, searches\nall `searchableAttributes`. Use this to restrict search to specific\nfields for better performance or relevance.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "explode": false
          },
          {
            "name": "hybridEmbedder",
            "in": "query",
            "description": "Name of the embedder to use for hybrid/semantic search. Must match an\nembedder configured in the index settings.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "hybridSemanticRatio",
            "in": "query",
            "description": "Balance between keyword search (0.0) and semantic/vector search (1.0)\nin hybrid search. A value of 0.5 gives equal weight to both. Defaults\nto `0.5`.",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "rankingScoreThreshold",
            "in": "query",
            "description": "Minimum ranking score (0.0 to 1.0) a document must have to be\nincluded in results. Documents with lower scores are excluded. Useful\nfor filtering out poor matches.",
            "required": true,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "locales",
            "in": "query",
            "description": "Comma-separated list of language locales to use for tokenization and\nprocessing. Useful for multilingual content. Example: `en,fr,de`.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Locale"
              }
            },
            "explode": false
          },
          {
            "name": "personalizeUserContext",
            "in": "query",
            "description": "User-specific context for personalized search results. The format\ndepends on your personalization configuration.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "useNetwork",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/search?q=american%20ninja'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').searchGet('American ninja')"
          }
        ]
      },
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Search with POST",
        "description": "Search for documents matching a specific query in the given index.",
        "operationId": "search_with_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SearchQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35,
                  "query": "american "
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/movies/search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{ \"q\": \"american ninja\" }'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->search('american ninja');"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').search('American ninja')"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").search(\"American ninja\");"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search('american ninja')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").Search(\"american ninja\", &meilisearch.SearchRequest{})"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").SearchAsync<Movie>(\"American ninja\");\nt_task_1: |\nTaskInfo task = await client.GetTaskAsync(1);\nt_all_tasks_1: |\nResourceResults<Task> taskResult = await client.GetTasksAsync();"
          },
          {
            "lang": "Rust",
            "source": "let results: SearchResults<Movie> = client\n  .index(\"movies\")\n  .search()\n  .with_query(\"american ninja\")\n  .execute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').search('American ninja');"
          },
          {
            "lang": "Swift",
            "source": "let searchParameters = SearchParameters(query: \"American ninja\")\nclient.index(\"movies\").search(searchParameters) { (result: Result<Searchable<Movie>, Swift.Error>) in\n    switch result {\n    case .success(let searchResult):\n        print(searchResult)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "List settings",
        "description": "This route allows you to retrieve, configure, or reset all of an index's settings at once.",
        "operationId": "get_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Settings are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Settings_Unchecked"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSettings()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSettings();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').settings"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSettings()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSettingsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let settings: Settings = client\n  .index(\"movies\")\n  .get_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSettings();\ndate_settings_1: \"await client.index('movies').updateSettings(\\n      IndexSettings(\\n        rankingRules: [\\n          'words',\\n          'typo',\\n          'proximity',\\n          'attribute',\\n          'sort',\\n          'exactness',\\n          'release_date:desc',\\n          'rank:desc'\\n        ],\\n        distinctAttribute: 'movie_id',\\n        searchableAttributes: ['title', 'overview', 'genres'],\\n        displayedAttributes: [\\n          'title',\\n          'overview',\\n          'genres',\\n          'release_date'\\n        ],\\n        stopWords: ['the', 'a', 'an'],\\n        sortableAttributes: ['title', 'release_date'],\\n        synonyms: {\\n          'wolverine': ['xmen', 'logan'],\\n          'logan': ['wolverine'],\\n        },\\n      ),\\n    );\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSettings { (result) in\n    switch result {\n    case .success(let setting):\n        print(setting)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset settings",
        "description": "Reset all the settings of an index to their default value.",
        "operationId": "delete_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSettings()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSettings();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_settings"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSettings()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSettingsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_settings()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSettings();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSettings { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update settings",
        "description": "Update the settings of an index.\nPassing null to an index setting will reset it to its default value.\nUpdates in the settings route are partial. This means that any parameters not provided in the body will be left unchanged.\nIf the provided index does not exist, it will be created.",
        "operationId": "update_all",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Settings_Unchecked"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/movies/settings' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"rankingRules\": [\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n    ],\n    \"distinctAttribute\": \"movie_id\",\n    \"searchableAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\"\n    ],\n    \"displayedAttributes\": [\n      \"title\",\n      \"overview\",\n      \"genres\",\n      \"release_date\"\n    ],\n    \"stopWords\": [\n      \"the\",\n      \"a\",\n      \"an\"\n    ],\n    \"sortableAttributes\": [\n      \"title\",\n      \"release_date\"\n    ],\n    \"synonyms\": {\n      \"wolverine\": [\n        \"xmen\",\n        \"logan\"\n    ],\n      \"logan\": [\"wolverine\"]\n    },\n    \"typoTolerance\": {\n      \"minWordSizeForTypos\": {\n        \"oneTypo\": 8,\n        \"twoTypos\": 10\n      },\n      \"disableOnAttributes\": [\"title\"]\n    },\n    \"pagination\": {\n      \"maxTotalHits\": 5000\n    },\n    \"faceting\": {\n      \"maxValuesPerFacet\": 200\n    },\n    \"searchCutoffMs\": 150\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSettings({\n    rankingRules: [\n        'words',\n        'typo',\n        'proximity',\n        'attribute',\n        'sort',\n        'exactness',\n        'release_date:desc',\n        'rank:desc'\n    ],\n    distinctAttribute: 'movie_id',\n    searchableAttributes: [\n        'title',\n        'overview',\n        'genres'\n    ],\n    displayedAttributes: [\n        'title',\n        'overview',\n        'genres',\n        'release_date'\n    ],\n    stopWords: [\n        'the',\n        'a',\n        'an'\n    ],\n    sortableAttributes: [\n      'title',\n      'release_date'\n    ],\n    synonyms: {\n        'wolverine': ['xmen', 'logan'],\n        'logan': ['wolverine']\n    },\n    typoTolerance: {\n        'minWordSizeForTypos': {\n            'oneTypo': 8,\n            'twoTypos': 10\n        },\n        'disableOnAttributes': [\n            'title'\n        ]\n    },\n    pagination: {\n        maxTotalHits: 5000\n    },\n    faceting: {\n        maxValuesPerFacet: 200\n    },\n    searchCutoffMs: 150\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSettings([\n  'rankingRules' => [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute' => 'movie_id',\n  'searchableAttributes' => [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes' => [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'stopWords' => [\n    'the',\n    'a',\n    'an'\n  ],\n  'sortableAttributes' => [\n    'title',\n    'release_date'\n  ],\n  'synonyms' => [\n    'wolverine' => ['xmen', 'logan'],\n    'logan' => ['wolverine']\n  ],\n  'typoTolerance' => [\n      'minWordSizeForTypos' => [\n        'oneTypo' => 8,\n        'twoTypos' => 10\n      ],\n      'disableOnAttributes' => ['title']\n  ],\n  'pagination' => [\n    'maxTotalHits' => 5000\n  ],\n  'faceting' => [\n    'maxValuesPerFacet' => 200\n  ],\n  'searchCutoffMs' => 150\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_settings({\n  'rankingRules': [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  'distinctAttribute': 'movie_id',\n  'searchableAttributes': [\n    'title',\n    'overview',\n    'genres'\n  ],\n  'displayedAttributes': [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  'sortableAttributes': [\n    'title',\n    'release_date'\n  ],\n  'stopWords': [\n    'the',\n    'a',\n    'an'\n  ],\n  'synonyms': {\n    'wolverine': ['xmen', 'logan'],\n    'logan': ['wolverine']\n  },\n  'typoTolerance': {\n    'minWordSizeForTypos': {\n        'oneTypo': 8,\n        'twoTypos': 10\n    },\n    'disableOnAttributes': ['title']\n  },\n  'pagination': {\n    'maxTotalHits': 5000\n  },\n  'faceting': {\n    'maxValuesPerFacet': 200\n  },\n  'searchCutoffMs': 150\n})"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(\n  new String[] {\n      \"words\",\n      \"typo\",\n      \"proximity\",\n      \"attribute\",\n      \"sort\",\n      \"exactness\",\n      \"release_date:desc\",\n      \"rank:desc\"\n  });\nsettings.setDistinctAttribute(\"movie_id\");\nsettings.setSearchableAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\"\n  });\nsettings.setDisplayedAttributes(\n  new String[] {\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  });\nsettings.setStopWords(\n  new String[] {\n    \"the\",\n    \"a\",\n    \"an\"\n  });\nsettings.setSortableAttributes(\n  new String[] {\n    \"title\",\n    \"release_date\"\n  });\n\nHashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nsettings.setSynonyms(synonyms);\n\nHashMap<String, Integer> minWordSizeTypos =\n  new HashMap<String, Integer>() {\n    {\n      put(\"oneTypo\", 8);\n      put(\"twoTypos\", 10);\n    }\n  };\nTypoTolerance typoTolerance = new TypoTolerance();\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\nsettings.setTypoTolerance(typoTolerance);\nsettings.setSearchCutoffMs(150);\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_settings({\n  ranking_rules: [\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:desc',\n    'rank:desc'\n  ],\n  distinct_attribute: 'movie_id',\n  searchable_attributes: [\n    'title',\n    'overview',\n    'genres'\n  ],\n  displayed_attributes: [\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n  ],\n  stop_words: [\n    'the',\n    'a',\n    'an'\n  ],\n  sortable_attributes: [\n    'title',\n    'release_date'\n  ],\n  synonyms: {\n    wolverine: ['xmen', 'logan'],\n    logan: ['wolverine']\n  },\n  pagination: {\n    max_total_hits: 5000\n  },\n  faceting: {\n    max_values_per_facet: 200\n  },\n  search_cutoff_ms: 150\n})"
          },
          {
            "lang": "Go",
            "source": "distinctAttribute := \"movie_id\"\nsettings := meilisearch.Settings{\n  RankingRules: []string{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\",\n  },\n  DistinctAttribute: &distinctAttribute,\n  SearchableAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n  },\n  DisplayedAttributes: []string{\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\",\n  },\n  StopWords: []string{\n    \"the\",\n    \"a\",\n    \"an\",\n  },\n  SortableAttributes: []string{\n    \"title\",\n    \"release_date\",\n  },\n  Synonyms: map[string][]string{\n    \"wolverine\": []string{\"xmen\", \"logan\"},\n    \"logan\":     []string{\"wolverine\"},\n  },\n  TypoTolerance: &meilisearch.TypoTolerance{\n    MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo:  8,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n  },\n  Pagination: &meilisearch.Pagination{\n    MaxTotalHits: 5000,\n  },\n  Faceting: &meilisearch.Faceting{\n    MaxValuesPerFacet: 200,\n  },\n  SearchCutoffMs: 150,\n}\nclient.Index(\"movies\").UpdateSettings(&settings)"
          },
          {
            "lang": "C#",
            "source": "Settings newSettings = new Settings\n{\n  RankingRules = new string[]\n  {\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  },\n  DistinctAttribute = \"movie_id\",\n  SearchableAttributes = new string[] { \"title\", \"overview\", \"genres\" },\n  DisplayedAttributes = new string[] { \"title\", \"overview\", \"genres\", \"release_date\" },\n  SortableAttributes = new string[] { \"title\", \"release_date\" },\n  StopWords = new string[] { \"the\", \"a\", \"an\" },\n  Synonyms = new Dictionary<string, IEnumerable<string>>\n  {\n      { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n      { \"logan\", new string[] { \"wolverine\" } },\n  },\n  FilterableAttributes = new string[] { },\n  TypoTolerance = new TypoTolerance\n  {\n      DisableOnAttributes = new string[] { \"title\" },\n      MinWordSizeForTypos = new TypoTolerance.TypoSize\n      {\n          OneTypo = 8,\n          TwoTypos = 10\n      }\n  },\n  SearchCutoffMs = 150\n};\nTaskInfo task = await client.Index(\"movies\").UpdateSettingsAsync(newFilters);"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![\"xmen\", \"logan\"]);\nsynonyms.insert(String::from(\"logan\"), vec![\"wolverine\"]);\n\nlet min_word_size_for_typos = MinWordSizeForTypos {\n  one_typo: Some(4),\n  two_typos; Some(12)\n}\nlet typo_tolerance = TypoToleranceSettings {\n  enabled: Some(true),\n  disable_on_attributes: Some(vec![\"title\".to_string()]),\n  disable_on_words: Some(vec![])\n  min_word_size_for_typos: Some(min_word_size_for_typos),\n};\n\nlet settings = Settings::new()\n  .with_ranking_rules([\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n  ])\n  .with_distinct_attribute(Some(\"movie_id\"))\n  .with_searchable_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ])\n  .with_displayed_attributes([\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ])\n  .with_stop_words([\n    \"the\",\n    \"a\",\n    \"an\"\n  ])\n  .with_sortable_attributes([\n    \"title\",\n    \"release_date\"\n  ])\n  .with_synonyms(synonyms)\n  .with_typo_tolerance(typo_tolerance)\n  .with_search_cutoff(150);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_settings(&settings)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let settings = Setting(rankingRules: [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:desc\",\n    \"rank:desc\"\n], searchableAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\"\n], displayedAttributes: [\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n], stopWords: [\n    \"the\",\n    \"a\",\n    \"an\"\n], synonyms: [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\"]\n], distinctAttribute: \"movie_id\",\nsortableAttributes: [\n    \"title\",\n    \"release_date\"\n])\nclient.index(\"movies\").updateSettings(settings) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/chat": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get chat",
        "description": "Get an user defined chat",
        "operationId": "getchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "chat is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ChatSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/chat'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset chat",
        "description": "Reset an index's chat to its default value",
        "operationId": "deletechat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/chat'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update chat",
        "description": "Update an index's user defined chat",
        "operationId": "patchchat",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChatSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/chat' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"description\": \"An index of movies.\",\n    \"documentTemplate\": \"A movie titled '{{doc.title}}' released in {{ doc.release_date }}\",\n    \"documentTemplateMaxBytes\": 400\n  }'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/dictionary": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get dictionary",
        "description": "Get an user defined dictionary",
        "operationId": "getdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "dictionary is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getDictionary()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getDictionary();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_dictionary()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getDictionarySettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').dictionary"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetDictionary()"
          },
          {
            "lang": "C#",
            "source": "var indexDictionary = await client.Index(\"books\").GetDictionaryAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .get_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getDictionary { result in\n  // handle result\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update dictionary",
        "description": "Update an index's user defined dictionary",
        "operationId": "putdictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/dictionary' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"J. R. R.\",\n    \"W. E. B.\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateDictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateDictionary(['J. R. R.', 'W. E. B.']);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_dictionary([\"J. R. R.\", \"W. E. B.\"])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateDictionarySettings(new String[] {\"J. R. R.\", \"W. E. B.\"});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_dictionary(['J. R. R.', 'W. E. B.'])"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateDictionary([]string{\n  \"J. R. R.\",\n  \"W. E. B.\",\n})"
          },
          {
            "lang": "C#",
            "source": "var newDictionary = new string[] { \"J. R. R.\", \"W. E. B.\" };\nawait client.Index(\"books\").UpdateDictionaryAsync(newDictionary);"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .set_dictionary(['J. R. R.', 'W. E. B.'])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateDictionary([\"J. R. R.\", \"W. E. B.\"]) { result in\n  // handle result\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset dictionary",
        "description": "Reset an index's dictionary to its default value",
        "operationId": "deletedictionary",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/dictionary'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetDictionary()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetDictionary();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_dictionary()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetDictionarySettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_dictionary"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetDictionary()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetDictionaryAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('books')\n  .reset_dictionary()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetDictionary { result in\n  // handle result\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/displayed-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get displayedAttributes",
        "description": "Get an user defined displayedAttributes",
        "operationId": "getdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "displayedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getDisplayedAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getDisplayedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_displayed_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getDisplayedAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').get_displayed_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetDisplayedAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetDisplayedAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getDisplayedAttributes();\ndate_displayed_attributes_1: \"await client.index('movies').updateDisplayedAttributes([\\n  'title',\\n  'overview',\\n  'genres',\\n  'release_date',\\n]);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getDisplayedAttributes { (result) in\n    switch result {\n    case .success(let displayedAttributes):\n        print(displayedAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update displayedAttributes",
        "description": "Update an index's user defined displayedAttributes",
        "operationId": "putdisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\",\n    \"release_date\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateDisplayedAttributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_displayed_attributes([\n    'title',\n    'overview',\n    'genres',\n    'release_date'\n])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateDisplayedAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_displayed_attributes([\n  'title',\n  'overview',\n  'genres',\n  'release_date'\n])"
          },
          {
            "lang": "Go",
            "source": "displayedAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\",\n}\nclient.Index(\"movies\").UpdateDisplayedAttributes(&displayedAttributes)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateDisplayedAttributesAsync(new[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n});"
          },
          {
            "lang": "Rust",
            "source": "let displayed_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\",\n  \"release_date\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_displayed_attributes(&displayed_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let displayedAttributes: [String] = [\"title\", \"overview\", \"genres\", \"release_date\"]\nclient.index(\"movies\").updateDisplayedAttributes(displayedAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset displayedAttributes",
        "description": "Reset an index's displayedAttributes to its default value",
        "operationId": "deletedisplayedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/displayed-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetDisplayedAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetDisplayedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_displayed_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetDisplayedAttributesSettings();\nt_typo_tolerance_1:\nclient.index(\"books\").getTypoToleranceSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_displayed_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetDisplayedAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetDisplayedAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_displayed_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetDisplayedAttributes();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetDisplayedAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/distinct-attribute": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get distinctAttribute",
        "description": "Get an user defined distinctAttribute",
        "operationId": "getdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "distinctAttribute is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": ""
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').getDistinctAttribute()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->getDistinctAttribute();"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').get_distinct_attribute()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").getDistinctAttributeSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').distinct_attribute"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").GetDistinctAttribute()"
          },
          {
            "lang": "C#",
            "source": "string result = await client.Index(\"shoes\").GetDistinctAttributeAsync();"
          },
          {
            "lang": "Rust",
            "source": "let distinct_attribute: Option<String> = client\n  .index(\"shoes\")\n  .get_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').getDistinctAttribute();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").getDistinctAttribute { (result) in\n    switch result {\n    case .success(let distinctAttribute):\n        print(distinctAttribute)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update distinctAttribute",
        "description": "Update an index's user defined distinctAttribute",
        "operationId": "putdistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"skuid\"'"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').updateDistinctAttribute('skuid')"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->updateDistinctAttribute('skuid');"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").updateDistinctAttributeSettings(\"skuid\");"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').update_distinct_attribute('skuid')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").UpdateDistinctAttribute(\"skuid\")"
          },
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").UpdateDistinctAttributeAsync(\"skuid\");"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .set_distinct_attribute(\"skuid\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').updateDistinctAttribute('skuid');"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").updateDistinctAttribute(\"skuid\") { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset distinctAttribute",
        "description": "Reset an index's distinctAttribute to its default value",
        "operationId": "deletedistinctAttribute",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/shoes/settings/distinct-attribute'"
          },
          {
            "lang": "JS",
            "source": "client.index('shoes').resetDistinctAttribute()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('shoes')->resetDistinctAttribute();"
          },
          {
            "lang": "Python",
            "source": "client.index('shoes').reset_distinct_attribute()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"shoes\").resetDistinctAttributeSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('shoes').reset_distinct_attribute"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"shoes\").ResetDistinctAttribute()"
          },
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"shoes\").ResetDistinctAttributeAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"shoes\")\n  .reset_distinct_attribute()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('shoes').resetDistinctAttribute();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"shoes\").resetDistinctAttribute { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/embedders": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get embedders",
        "description": "Get an user defined embedders",
        "operationId": "getembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "embedders is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/SettingEmbeddingSettings"
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').embedders"
          },
          {
            "lang": "Rust",
            "source": "let embedders = index.get_embedders().await.unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset embedders",
        "description": "Reset an index's embedders to its default value",
        "operationId": "deleteembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders'"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').reset_embedders"
          },
          {
            "lang": "Rust",
            "source": "index.reset_embedders().await.unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update embedders",
        "description": "Update an index's user defined embedders",
        "operationId": "patchembedders",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SettingEmbeddingSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/embedders' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"default\": {\n      \"source\":  \"openAi\",\n      \"apiKey\": \"OPEN_AI_API_KEY\",\n      \"model\": \"text-embedding-3-small\",\n      \"documentTemplate\": \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n    }\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateEmbedders({\n  default: {\n    source: 'openAi',\n    apiKey: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    documentTemplate: 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  }\n});"
          },
          {
            "lang": "PHP",
            "source": "$client->updateEmbedders([\n  'default' => [\n    'source' => 'openAi',\n    'apiKey' => 'OPEN_AI_API_KEY',\n    'model' => 'text-embedding-3-small',\n    'documentTemplate' => 'A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}'\n  ]\n]);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').update_embedders(\n  default: {\n    source:  'openAi',\n    api_key: 'OPEN_AI_API_KEY',\n    model: 'text-embedding-3-small',\n    document_template: \"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\"\n  }\n)"
          },
          {
            "lang": "Rust",
            "source": "let embedders = HashMap::from([(\n  String::from(\"default\"),\n  Embedder {\n    source: EmbedderSource::OpenAi,\n    api_key: Some(String::from(\"OPEN_AI_API_KEY\")),\n    model: Some(String::from(\"text-embedding-3-small\")),\n    document_template: Some(String::from(\"A document titled '{{doc.title}}' whose description starts with {{doc.overview|truncatewords: 20}}\")),\n    ..Embedder::default()\n  }\n)]);\nlet task = index\n  .set_embedders(&embedders)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/facet-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get facetSearch",
        "description": "Get an user defined facetSearch",
        "operationId": "getfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "facetSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "boolean"
                },
                "example": false
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getFacetSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getFacetSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_facet_search_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').facet_search_setting"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetFacetSearch()"
          },
          {
            "lang": "Rust",
            "source": "let facet_search: bool = client\n  .index(INDEX_UID)\n  .get_facet_search()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update facetSearch",
        "description": "Update an index's user defined facetSearch",
        "operationId": "putfacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary 'false'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateFacetSearch(false);"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updateFacetSearch(false);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_facet_search_settings(False)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').update_facet_search_setting(false)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateFacetSearch(false)"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_facet_search(false)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset facetSearch",
        "description": "Reset an index's facetSearch to its default value",
        "operationId": "deletefacetSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "boolean"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/facet-search'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetFacetSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetFacetSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_facet_search_settings()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').reset_facet_search_setting"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetFacetSearch()"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_facet_search()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/faceting": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get faceting",
        "description": "Get an user defined faceting",
        "operationId": "getfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "faceting is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FacetingSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getFaceting()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getFaceting();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_faceting_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getFacetingSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').faceting"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetFaceting()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetFacetingAsync();"
          },
          {
            "lang": "Rust",
            "source": "let faceting: FacetingSettings = client\n  .index(\"books\")\n  .get_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getFaceting();\ndate_faceting_settings_1: \"await client.index('books').updateFaceting(Faceting(\\n        maxValuesPerFacet: 2,\\n        sortFacetValuesBy: {\\n          '*': FacetingSortTypes.alpha,\\n          'genres': FacetingSortTypes.count\\n        }));\""
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset faceting",
        "description": "Reset an index's faceting to its default value",
        "operationId": "deletefaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/faceting'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetFaceting()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetFaceting();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_faceting_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetFacetingSettings();"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_faceting"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetFaceting()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetFacetingAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_faceting()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetFaceting();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update faceting",
        "description": "Update an index's user defined faceting",
        "operationId": "patchfaceting",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FacetingSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/faceting' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxValuesPerFacet\": 2,\n    \"sortFacetValuesBy\": {\n      \"*\": \"alpha\",\n      \"genres\": \"count\"\n    }\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateFaceting({\n  maxValuesPerFacet: 2\n  sortFacetValuesBy: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateFaceting([\n  'maxValuesPerFacet' => 2,\n  'sortFacetValuesBy' => ['*' => 'alpha', 'genres' => 'count']\n]);"
          },
          {
            "lang": "Python",
            "source": "params = {\n  'maxValuesPerFacet': 2,\n  'sortFacetValuesBy': {\n      '*': 'count',\n      'genres': 'count'\n    }\n}\nclient.index('books').update_faceting_settings(params)"
          },
          {
            "lang": "Java",
            "source": "Faceting newFaceting = new Faceting();\nnewFaceting.setMaxValuesPerFacet(2);\nHashMap<String, FacetSortValue> facetSortValues = new HashMap<>();\nfacetSortValues.put(\"*\", FacetSortValue.ALPHA);\nfacetSortValues.put(\"genres\", FacetSortValue.COUNT);\nnewFaceting.setSortFacetValuesBy(facetSortValues);\nclient.index(\"books\").updateFacetingSettings(newFaceting);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_faceting({\n  max_values_per_facet: 2,\n  sort_facet_values_by: {\n    '*': 'alpha',\n    genres: 'count'\n  }\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateFaceting(&meilisearch.Faceting{\n    MaxValuesPerFacet: 2,\n    SortFacetValuesBy: {\n       \"*\":      SortFacetTypeAlpha,\n       \"genres\": SortFacetTypeCount,\n    }\n})"
          },
          {
            "lang": "C#",
            "source": "var faceting = new Faceting\n{\n    MaxValuesPerFacet = 2,\n    SortFacetValuesBy = new Dictionary<string, SortFacetValuesByType>\n    {\n        [\"*\"] = SortFacetValuesByType.Alpha,\n        [\"genres\"] = SortFacetValuesByType.Count\n    }\n};\nawait client.Index(\"books\").UpdateFacetingAsync(faceting);"
          },
          {
            "lang": "Rust",
            "source": "let mut facet_sort_setting = BTreeMap::new();\nfacet_sort_setting.insert(String::from(\"*\"), FacetSortValue::Alpha);\nfacet_sort_setting.insert(String::from(\"genres\"), FacetSortValue::Count);\nlet mut faceting = FacetingSettings {\n  max_values_per_facet: 2,\n  sort_facet_values_by: Some(facet_sort_setting),\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_faceting(&faceting)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/filterable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get filterableAttributes",
        "description": "Get an user defined filterableAttributes",
        "operationId": "getfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "filterableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FilterableAttributesRule"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getFilterableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getFilterableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_filterable_attributes()"
          },
          {
            "lang": "Java",
            "source": "// Granular filterable attributes API (v1.14+)\nclient.index(\"movies\").getGranularFilterableAttributesSettings();\n// Legacy String[] API\nclient.index(\"movies\").getFilterableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').filterable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetFilterableAttributes()"
          },
          {
            "lang": "C#",
            "source": "IEnumerable<string> attributes = await client.Index(\"movies\").GetFilterableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let filterable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getFilterableAttributes();\ndate_filterable_attributes_1: \"await client\\n    .index('movies')\\n    .updateFilterableAttributes(['genres', 'director']);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update filterableAttributes",
        "description": "Update an index's user defined filterableAttributes",
        "operationId": "putfilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"genres\",\n    \"director\",\n    {\n      \"attributePatterns\": [\"*_ratings\"],\n      \"features\": {\n        \"facetSearch\": false,\n        \"filter\": {\n          \"equality\": true,\n          \"comparison\": false\n        }\n      }\n    }\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies')\n  .updateFilterableAttributes([\n    \"genres\",\n    {\n      attributePatterns: [\"genre\"],\n      features: {\n        facetSearch: true,\n        filter: { equality: true, comparison: false },\n      },\n    }\n  ])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateFilterableAttributes([\n  'author',\n  [\n      'attributePatterns' => ['genres'],\n      'features' => [\n          'facetSearch' => true,\n          'filter' => [\n              'equality' => true,\n              'comparison' => false,\n          ],\n      ],\n  ],\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "Java",
            "source": "FilterableAttributesConfig genres = FilterableAttributesConfig.simple(\"genres\");\n\nFilterableAttributesFilter directorFilter = new FilterableAttributesFilter();\ndirectorFilter.setEquality(true);\ndirectorFilter.setComparison(false);\n\nFilterableAttributesFeatures directorFeatures = new FilterableAttributesFeatures();\ndirectorFeatures.setFacetSearch(true);\ndirectorFeatures.setFilter(directorFilter);\n\nFilterableAttributesConfig director = new FilterableAttributesConfig();\ndirector.setAttributePatterns(new String[] {\"director\"});\ndirector.setFeatures(directorFeatures);\n\n// Update settings\nclient.index(\"movies\").updateGranularFilterableAttributesSettings(\n  new FilterableAttributesConfig[] {genres, director});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_filterable_attributes([\n  'genres',\n  'director'\n])"
          },
          {
            "lang": "Go",
            "source": "filterableAttributes := []interface{}{\n  \"genres\",\n  \"director\",\n  AttributeRule{\n    AttributePatterns: []string{\"tag\"}\n    Features: AttributeFeatures{\n      FacetSearch: false,\n      Filter: FilterFeatures{\n        Equality:   true,\n        Comparison: false,\n      }\n    }\n  },\n  map[string]interface{}{\n    \"attributePatterns\": []interface{}{\"year\"}\n    \"features\": map[string]interface{}{\n      \"facetSearch\": false,\n      \"filter\": map[string]interface{}{\n        \"equality\":   true,\n        \"comparison\": true,\n      }\n    }\n  }\n}\nclient.Index(\"movies\").UpdateFilterableAttributes(&filterableAttributes)"
          },
          {
            "lang": "C#",
            "source": "List<string> attributes = new() { \"genres\", \"director\" };\nTaskInfo result = await client.Index(\"movies\").UpdateFilterableAttributesAsync(attributes);"
          },
          {
            "lang": "Rust",
            "source": "use meilisearch_sdk::settings::{\n  FilterableAttribute,\n  FilterableAttributesSettings,\n  FilterFeatures,\n  FilterFeatureModes,\n};\n\n// Mixed legacy + new syntax\nlet filterable_attributes: Vec<FilterableAttribute> = vec![\n  // legacy: plain attribute name\n  \"author\".into(),\n  // new syntax: settings object\n  FilterableAttribute::Settings(FilterableAttributesSettings {\n    attribute_patterns: vec![\"genre\".to_string()],\n    features: FilterFeatures {\n      facet_search: true,\n      filter: FilterFeatureModes { equality: true, comparison: false },\n    },\n  }),\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_filterable_attributes_advanced(filterable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").updateFilterableAttributes([\"genre\", \"director\"]) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset filterableAttributes",
        "description": "Reset an index's filterableAttributes to its default value",
        "operationId": "deletefilterableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FilterableAttributesRule"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/filterable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetFilterableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetFilterableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_filterable_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetFilterableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_filterable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetFilterableAttributes()"
          },
          {
            "lang": "C#",
            "source": "TaskInfo result = await client.Index(\"movies\").ResetFilterableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_filterable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetFilterableAttributes();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetFilterableAttributes { (result) in\n    switch result {\n    case .success(let attributes):\n        print(attributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/localized-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get localizedAttributes",
        "description": "Get an user defined localizedAttributes",
        "operationId": "getlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "localizedAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getLocalizedAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getLocalizedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').get_localized_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").getLocalizedAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').localized_attributes"
          },
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").GetLocalizedAttributes()"
          },
          {
            "lang": "Rust",
            "source": "let localized_attributes: Option<Vec<LocalizedAttributes>> = client\n  .index(\"books\")\n  .get_localized_attributes()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update localizedAttributes",
        "description": "Update an index's user defined localizedAttributes",
        "operationId": "putlocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\"locales\": [\"jpn\"], \"attributePatterns\": [\"*_ja\"]}\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updateLocalizedAttributes([\n  { attributePatterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updateLocalizedAttributes([\n  'locales' => ['jpn'],\n  'attributePatterns' => ['*_ja']\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  {'attribute_patterns': ['*_ja'], 'locales': ['jpn']}\n])"
          },
          {
            "lang": "Java",
            "source": "LocalizedAttribute attribute = new LocalizedAttribute();\nattribute.setAttributePatterns(new String[] {\"jpn\"});\nattribute.setLocales(new String[] {\"*_ja\"});\n\nclient.index(\"INDEX_NAME\").updateLocalizedAttributesSettings(\n  new LocalizedAttributes[] {attribute}\n);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').update_localized_attributes([\n  { attribute_patterns: ['*_ja'], locales: ['jpn'] },\n])"
          },
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").UpdateLocalizedAttributes([]*LocalizedAttributes{\n    { AttributePatterns: [\"*_ja\"], Locales: [\"jpn\"] },\n})"
          },
          {
            "lang": "Rust",
            "source": "let localized_attributes = vec![LocalizedAttributes {\n    locales: vec![\"jpn\".to_string()],\n    attribute_patterns: vec![\"*_ja\".to_string()],\n}];\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_localized_attributes(&localizced_attributes)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset localizedAttributes",
        "description": "Reset an index's localizedAttributes to its default value",
        "operationId": "deletelocalizedAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LocalizedAttributesRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_NAME/settings/localized-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetLocalizedAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetLocalizedAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('INDEX_NAME').reset_localized_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"INDEX_NAME\").resetLocalizedAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').reset_localized_attributes"
          },
          {
            "lang": "Go",
            "source": "client.index(\"INDEX_NAME\").ResetLocalizedAttributes()"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_localized_attributes()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/non-separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get nonSeparatorTokens",
        "description": "Get an user defined nonSeparatorTokens",
        "operationId": "getnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "nonSeparatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getNonSeparatorTokens()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->getNonSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').get_non_separator_tokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").getNonSeparatorTokensSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').non_separator_tokens"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").GetNonSeparatorTokens()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetNonSeparatorTokensAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getNonSeparatorTokens { result in\n  // handle result\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update nonSeparatorTokens",
        "description": "Update an index's user defined nonSeparatorTokens",
        "operationId": "putnonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"@\", \"#\"]'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateNonSeparatorTokens(['@', '#'])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->updateNonSeparatorTokens(['@', '#']);"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').update_non_separator_tokens([\"@\", \"#\"])"
          },
          {
            "lang": "Java",
            "source": "String[] newSeparatorTokens = { \"@\", \"#\" };\nclient.index(\"articles\").updateNonSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').update_non_separator_tokens(['@', '#'])"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").UpdateNonSeparatorTokens([]string{\n  \"@\",\n  \"#\",\n})"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateNonSeparatorTokensAsync(new[] { \"@\", \"#\" });"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_non_separator_tokens(&vec!['@'.to_string(), '#'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateNonSeparatorTokens([\"@\", \"#\"]) { result in\n  // handle result\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset nonSeparatorTokens",
        "description": "Reset an index's nonSeparatorTokens to its default value",
        "operationId": "deletenonSeparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/non-separator-tokens'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetNonSeparatorTokens()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->resetNonSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').reset_non_separator_tokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").resetNonSeparatorTokensSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').reset_non_separator_tokens"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").ResetNonSeparatorTokens()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetNonSeparatorTokensAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_non_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetNonSeparatorTokens { result in\n  // handle result\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/pagination": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get pagination",
        "description": "Get an user defined pagination",
        "operationId": "getpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "pagination is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getPagination()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getPagination();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_pagination_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getPaginationSettings();"
          },
          {
            "lang": "Ruby",
            "source": "index('books').pagination"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetPagination()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetPaginationAsync();"
          },
          {
            "lang": "Rust",
            "source": "let pagination: PaginationSetting = client\n  .index(\"books\")\n  .get_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getPagination();\ndate_pagination_settings_1: \"await client\\n    .index('books')\\n    .updatePagination(Pagination(maxTotalHits: 100));\""
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset pagination",
        "description": "Reset an index's pagination to its default value",
        "operationId": "deletepagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/pagination'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetPagination()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetPagination();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_pagination_settings()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetPaginationSettings();"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_pagination"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetPagination()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetPaginationAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_pagination()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetPagination();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update pagination",
        "description": "Update an index's user defined pagination",
        "operationId": "patchpagination",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PaginationSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/pagination' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"maxTotalHits\": 100\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateSettings({ pagination: { maxTotalHits: 100 }})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateSettings([\n  'pagination' => [\n    'maxTotalHits' => 100\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_pagination_settings({'maxTotalHits': 100})"
          },
          {
            "lang": "Java",
            "source": "Pagination newPagination = new Pagination();\nnewPagination.setMaxTotalHits(100);\nclient.index(\"books\").updatePaginationSettings(newPagination);"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_pagination({ max_total_hits: 100 })"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdatePagination(&meilisearch.Pagination{\n    MaxTotalHits: 100,\n})"
          },
          {
            "lang": "C#",
            "source": "var pagination = new Pagination {\n  MaxTotalHits = 20\n};\nawait client.Index(\"movies\").UpdatePaginationAsync(pagination);"
          },
          {
            "lang": "Rust",
            "source": "let pagination = PaginationSetting {max_total_hits:100};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_pagination(pagination)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/prefix-search": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get prefixSearch",
        "description": "Get an user defined prefixSearch",
        "operationId": "getprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "prefixSearch is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PrefixSearchSettings"
                },
                "example": "indexingTime"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').getPrefixSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->getPrefixSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_prefix_search()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').prefix_search"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetPrefixSearch()"
          },
          {
            "lang": "Rust",
            "source": "let prefix_search: PrefixSearchSettings = client\n  .index(INDEX_UID)\n  .get_prefix_search()\n  .await\n  .unwrap();"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update prefixSearch",
        "description": "Update an index's user defined prefixSearch",
        "operationId": "putprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"disabled\"'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').updatePrefixSearch('disabled');"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->updatePrefixSearch('disabled');"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_prefix_search(PrefixSearch.DISABLED)"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').update_prefix_search('disabled')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdatePrefixSearch(\"disabled\")"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .set_prefix_search(PrefixSearchSettings::Disabled)\n  .await\n  .unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset prefixSearch",
        "description": "Reset an index's prefixSearch to its default value",
        "operationId": "deleteprefixSearch",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PrefixSearchSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/prefix-search'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').resetPrefixSearch();"
          },
          {
            "lang": "PHP",
            "source": "$client->index('INDEX_NAME')->resetPrefixSearch();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_prefix_search()"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_UID').reset_prefix_search"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetPrefixSearch()"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(INDEX_UID)\n  .reset_prefix_search()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/proximity-precision": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get proximityPrecision",
        "description": "Get an user defined proximityPrecision",
        "operationId": "getproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "proximityPrecision is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProximityPrecisionView"
                },
                "example": "byWord"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getProximityPrecision()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getProximityPrecision();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_proximity_precision()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getProximityPrecisionSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').proximity_precision"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetProximityPrecision()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").GetProximityPrecisionAsync();"
          },
          {
            "lang": "Rust",
            "source": "let proximity_precision: String = client\n  .index(\"books\")\n  .get_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getProximityPrecision()"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update proximityPrecision",
        "description": "Update an index's user defined proximityPrecision",
        "operationId": "putproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/proximity-precision' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"byAttribute\"'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateProximityPrecision('byAttribute')"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateProximityPrecision('byAttribute');"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_proximity_precision(ProximityPrecision.BY_ATTRIBUTE)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateProximityPrecisionSettings(\"byAttribute\");"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_proximity_precision('byAttribute')"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateProximityPrecision(ByAttribute)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateProximityPrecisionAsync(\"byAttribute\");"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .set_proximity_precision(\"byAttribute\".to_string())\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateProximityPrecision(.byWord)"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset proximityPrecision",
        "description": "Reset an index's proximityPrecision to its default value",
        "operationId": "deleteproximityPrecision",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProximityPrecisionView"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/proximity-precision'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetProximityPrecision()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetProximityPrecision();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_proximity_precision()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetProximityPrecisionSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_proximity_precision"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetProximityPrecision()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetProximityPrecisionAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_proximity_precision()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetProximityPrecision()"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/ranking-rules": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get rankingRules",
        "description": "Get an user defined rankingRules",
        "operationId": "getrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "rankingRules is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RankingRuleView"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getRankingRules()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getRankingRules();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_ranking_rules()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getRankingRulesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').ranking_rules"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetRankingRules()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetRankingRulesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules: Vec<String> = client\n  .index(\"movies\")\n  .get_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getRankingRules();\ndate_ranking_rules_1: \"await client.index('movies').updateRankingRules([\\n  'words',\\n  'typo',\\n  'proximity',\\n  'attribute',\\n  'sort',\\n  'exactness',\\n  'release_date:asc',\\n  'rank:desc',\\n]);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getRankingRules { (result) in\n    switch result {\n    case .success(let rankingRules):\n        print(rankingRules)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update rankingRules",
        "description": "Update an index's user defined rankingRules",
        "operationId": "putrankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateRankingRules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateRankingRules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_ranking_rules([\n    'words',\n    'typo',\n    'proximity',\n    'attribute',\n    'sort',\n    'exactness',\n    'release_date:asc',\n    'rank:desc'\n])"
          },
          {
            "lang": "Java",
            "source": "Settings settings = new Settings();\nsettings.setRankingRules(new String[]\n{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\"\n});\nclient.index(\"movies\").updateSettings(settings);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_ranking_rules([\n  'words',\n  'typo',\n  'proximity',\n  'attribute',\n  'sort',\n  'exactness',\n  'release_date:asc',\n  'rank:desc'\n])"
          },
          {
            "lang": "Go",
            "source": "rankingRules := []string{\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n}\nclient.Index(\"movies\").UpdateRankingRules(&rankingRules)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateRankingRulesAsync(new[]\n{\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n});"
          },
          {
            "lang": "Rust",
            "source": "let ranking_rules = [\n  \"words\",\n  \"typo\",\n  \"proximity\",\n  \"attribute\",\n  \"sort\",\n  \"exactness\",\n  \"release_date:asc\",\n  \"rank:desc\",\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_ranking_rules(&ranking_rules)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let rankingRules: [String] = [\n    \"words\",\n    \"typo\",\n    \"proximity\",\n    \"attribute\",\n    \"sort\",\n    \"exactness\",\n    \"release_date:asc\",\n    \"rank:desc\"\n]\nclient.index(\"movies\").updateRankingRules(rankingRules) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset rankingRules",
        "description": "Reset an index's rankingRules to its default value",
        "operationId": "deleterankingRules",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RankingRuleView"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/ranking-rules'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetRankingRules()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetRankingRules();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_ranking_rules()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetRankingRulesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_ranking_rules"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetRankingRules()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetRankingRulesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_ranking_rules()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetRankingRules();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetRankingRules { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/search-cutoff-ms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchCutoffMs",
        "description": "Get an user defined searchCutoffMs",
        "operationId": "getsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchCutoffMs is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "integer",
                  "format": "u-int64",
                  "minimum": 0
                },
                "example": 0
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSearchCutoffMs()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSearchCutoffMs();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_search_cutoff_ms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSearchCutoffMsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').search_cutoff_ms"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSearchCutoffMs()"
          },
          {
            "lang": "C#",
            "source": "var searchCutoff = await client.Index(\"movies\").GetSearchCutoffMsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let search_cutoff_ms: String = client\n  .index(\"movies\")\n  .get_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let precisionValue = try await self.client.index(\"books\").getSearchCutoffMs()"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchCutoffMs",
        "description": "Update an index's user defined searchCutoffMs",
        "operationId": "putsearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '150'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchCutoffMs(150)"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchCutoffMs(150);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateSearchCutoffMsSettings(150);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_search_cutoff_ms(150)"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").UpdateSearchCutoffMs(150)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchCutoffMsAsync(150);"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .set_search_cutoff_ms(Some(150))\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").updateSearchCutoffMs(150)"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchCutoffMs",
        "description": "Reset an index's searchCutoffMs to its default value",
        "operationId": "deletesearchCutoffMs",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "text/plain": {
              "schema": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/search-cutoff-ms'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSearchCutoffMs()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSearchCutoffMs();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_search_cutoff_ms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSearchCutoffMsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_search_cutoff_ms"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetSearchCutoffMs()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSearchCutoffMsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_search_cutoff_ms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.index(\"books\").resetSearchCutoffMs()"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/searchable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get searchableAttributes",
        "description": "Get an user defined searchableAttributes",
        "operationId": "getsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "searchableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSearchableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSearchableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_searchable_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSearchableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').searchable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSearchableAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSearchableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes: Vec<String> = client\n  .index(\"movies\")\n  .get_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSearchableAttributes();\ndate_searchable_attributes_1: \"await client\\n    .index('movies')\\n    .updateSearchableAttributes(['title', 'overview', 'genres']);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSearchableAttributes { (result) in\n    switch result {\n    case .success(let searchableAttributes):\n        print(searchableAttributes)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update searchableAttributes",
        "description": "Update an index's user defined searchableAttributes",
        "operationId": "putsearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"title\",\n    \"overview\",\n    \"genres\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSearchableAttributes([\n  'title',\n  'overview',\n  'genres'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_searchable_attributes([\n    'title',\n    'overview',\n    'genres'\n])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateSearchableAttributesSettings(new String[]\n{\n  \"title\",\n  \"overview\",\n  \"genres\"\n});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_searchable_attributes([\n  'title',\n  'overview',\n  'genres'\n])"
          },
          {
            "lang": "Go",
            "source": "searchableAttributes := []string{\n  \"title\",\n  \"overview\",\n  \"genres\",\n}\nclient.Index(\"movies\").UpdateSearchableAttributes(&searchableAttributes)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSearchableAttributesAsync(new[] {\"title\", \"overview\", \"genres\"});"
          },
          {
            "lang": "Rust",
            "source": "let searchable_attributes = [\n  \"title\",\n  \"overview\",\n  \"genres\"\n];\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_searchable_attributes(&searchable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let searchableAttributes: [String] = [\"title\", \"overview\", \"genres\"]\nclient.index(\"movies\").updateSearchableAttributes(searchableAttributes) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset searchableAttributes",
        "description": "Reset an index's searchableAttributes to its default value",
        "operationId": "deletesearchableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/searchable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSearchableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSearchableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_searchable_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSearchableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_searchable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSearchableAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSearchableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_searchable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSearchableAttributes();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSearchableAttributes { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/separator-tokens": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get separatorTokens",
        "description": "Get an user defined separatorTokens",
        "operationId": "getseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "separatorTokens is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getSeparatorTokens()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->getSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').get_separator_tokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").getSeparatorTokensSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').separator_tokens"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").GetSeparatorTokens()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSeparatorTokensAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .get_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getSeparatorTokens { result in\n  // handle result\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update separatorTokens",
        "description": "Update an index's user defined separatorTokens",
        "operationId": "putseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens' \\\n  -H 'Content-Type: application/json'  \\\n  --data-binary '[\"|\", \"&hellip;\"]'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateSeparatorTokens(['|', '&hellip;'])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->updateSeparatorTokens(['|', '&hellip;']);"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').update_separator_tokens([\"|\", \"&hellip;\"])"
          },
          {
            "lang": "Java",
            "source": "String[] newSeparatorTokens = { \"|\", \"&hellip;\" };\nclient.index(\"articles\").updateSeparatorTokensSettings(newSeparatorTokens);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').update_separator_tokens(['|', '&hellip;'])"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").UpdateSeparatorTokens([]string{\n  \"|\",\n  \"&hellip;\",\n})"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateSeparatorTokensAsync(new[] { \"|\", \"&hellip;\" });"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .set_separator_tokens(&vec!['|'.to_string(), '&hellip;'.to_string()])\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateSeparatorTokens([\"|\", \"&hellip;\"]) { result in\n  // handle result\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset separatorTokens",
        "description": "Reset an index's separatorTokens to its default value",
        "operationId": "deleteseparatorTokens",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/articles/settings/separator-tokens'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetSeparatorTokens()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('articles')->resetSeparatorTokens();"
          },
          {
            "lang": "Python",
            "source": "client.index('articles').reset_separator_tokens()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"articles\").resetSeparatorTokensSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('articles').reset_separator_tokens"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"articles\").ResetSeparatorTokens()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSeparatorTokensAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index('articles')\n  .reset_separator_tokens()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetSeparatorTokens { result in\n  // handle result\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/sortable-attributes": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get sortableAttributes",
        "description": "Get an user defined sortableAttributes",
        "operationId": "getsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "sortableAttributes is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getSortableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getSortableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_sortable_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").getSortableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').sortable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetSortableAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").GetSortableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let sortable_attributes: Vec<String> = client\n  .index(\"books\")\n  .get_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').getSortableAttributes();\ndate_sortable_attributes_1: \"await client.index('books').updateSortableAttributes(['price', 'author']);\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").getSortableAttributes { (result: Result<Searchable<Book>, Swift.Error>) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update sortableAttributes",
        "description": "Update an index's user defined sortableAttributes",
        "operationId": "putsortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"price\",\n    \"author\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('books')\n  .updateSortableAttributes([\n    'price',\n    'author'\n  ])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateSortableAttributes([\n  'price',\n  'author'\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").updateSortableAttributesSettings(new String[] {\"price\", \"author\"});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').update_sortable_attributes([\n  'price',\n  'author'\n])"
          },
          {
            "lang": "Go",
            "source": "sortableAttributes := []string{\n  \"price\",\n  \"author\",\n}\nclient.Index(\"books\").UpdateSortableAttributes(&sortableAttributes)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").UpdateSortableAttributesAsync(new [] { \"price\", \"author\" });"
          },
          {
            "lang": "Rust",
            "source": "let sortable_attributes = [\n  \"price\",\n  \"author\"\n];\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_sortable_attributes(&sortable_attributes)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").updateSortableAttributes([\"price\", \"author\"]) { (result) in\n  switch result {\n  case .success(let task):\n    print(task)\n  case .failure(let error):\n    print(error)\n  }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset sortableAttributes",
        "description": "Reset an index's sortableAttributes to its default value",
        "operationId": "deletesortableAttributes",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/sortable-attributes'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetSortableAttributes()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetSortableAttributes();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_sortable_attributes()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetSortableAttributesSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('books').reset_sortable_attributes"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetSortableAttributes()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetSortableAttributesAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_sortable_attributes()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').resetSortableAttributes();\narch_parameter_guide_sort_1: \"await client\\n    .index('books')\\n    .search('science fiction', SearchQuery(sort: ['price:asc']));\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"books\").resetSortableAttributes() { (result) in\n  switch result {\n  case .success(let attributes):\n    print(attributes)\n  case .failure(let error):\n    print(error)\n  }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/stop-words": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get stopWords",
        "description": "Get an user defined stopWords",
        "operationId": "getstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "stopWords is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "uniqueItems": true
                },
                "example": []
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getStopWords()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getStopWords();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_stop_words()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getStopWordsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').stop_words"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetStopWords()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetStopWordsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let stop_words: Vec<String> = client\n  .index(\"movies\")\n  .get_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getStopWords();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getStopWords { (result) in\n    switch result {\n    case .success(let stopWords):\n        print(stopWords)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update stopWords",
        "description": "Update an index's user defined stopWords",
        "operationId": "putstopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/stop-words' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    \"the\",\n    \"of\",\n    \"to\"\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateStopWords(['of', 'the', 'to'])"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateStopWords(['the', 'of', 'to']);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").updateStopWordsSettings(new String[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_stop_words(['of', 'the', 'to'])"
          },
          {
            "lang": "Go",
            "source": "stopWords := []string{\"of\", \"the\", \"to\"}\nclient.Index(\"movies\").UpdateStopWords(&stopWords)"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").UpdateStopWordsAsync(new[] {\"of\", \"the\", \"to\"});"
          },
          {
            "lang": "Rust",
            "source": "let stop_words = [\"of\", \"the\", \"to\"];\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_stop_words(&stop_words)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').updateStopWords(['of', 'the', 'to']);"
          },
          {
            "lang": "Swift",
            "source": "let stopWords: [String] = [\"of\", \"the\", \"to\"]\nclient.index(\"movies\").updateStopWords(stopWords) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset stopWords",
        "description": "Reset an index's stopWords to its default value",
        "operationId": "deletestopWords",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "uniqueItems": true
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/stop-words'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetStopWords()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetStopWords();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_stop_words()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetStopWordsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_stop_words"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetStopWords()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetStopWordsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_stop_words()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetStopWords();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetStopWords { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/synonyms": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get synonyms",
        "description": "Get an user defined synonyms",
        "operationId": "getsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "synonyms is returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getSynonyms()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->getSynonyms();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_synonyms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getSynonymsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').synonyms"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetSynonyms()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetSynonymsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let synonyms: HashMap<String, Vec<String>> = client\n  .index(\"movies\")\n  .get_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getSynonyms();\ndate_synonyms_1: \"await client.index('movies').updateSynonyms({\\n  'wolverine': ['xmen', 'logan'],\\n  'logan': ['wolverine', 'xmen'],\\n  'wow': ['world of warcraft'],\\n});\""
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").getSynonyms { (result) in\n    switch result {\n    case .success(let synonyms):\n        print(synonyms)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "put": {
        "tags": [
          "Settings"
        ],
        "summary": "Update synonyms",
        "description": "Update an index's user defined synonyms",
        "operationId": "putsynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PUT 'MEILISEARCH_URL/indexes/movies/settings/synonyms' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"wolverine\": [\n      \"xmen\",\n      \"logan\"\n    ],\n    \"logan\": [\n      \"wolverine\",\n      \"xmen\"\n    ],\n    \"wow\": [\"world of warcraft\"]\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').updateSynonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->updateSynonyms([\n  'wolverine' => ['xmen', 'logan'],\n  'logan' => ['wolverine', 'xmen'],\n  'wow' => ['world of warcraft']\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').update_synonyms({\n  'wolverine': ['xmen', 'logan'],\n  'logan': ['wolverine', 'xmen'],\n  'wow': ['world of warcraft']\n})"
          },
          {
            "lang": "Java",
            "source": "HashMap<String, String[]> synonyms = new HashMap<String, String[]>();\nsynonyms.put(\"wolverine\", new String[] {\"xmen\", \"logan\"});\nsynonyms.put(\"logan\", new String[] {\"wolverine\"});\nclient.index(\"movies\").updateSynonymsSettings(synonyms);"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').update_synonyms({\n  wolverine: ['xmen', 'logan'],\n  logan: ['wolverine', 'xmen'],\n  wow: ['world of warcraft']\n})"
          },
          {
            "lang": "Go",
            "source": "synonyms := map[string][]string{\n  \"wolverine\": []string{\"xmen\", \"logan\"},\n  \"logan\":     []string{\"wolverine\", \"xmen\"},\n  \"wow\":       []string{\"world of warcraft\"},\n}\nclient.Index(\"movies\").UpdateSynonyms(&synonyms)"
          },
          {
            "lang": "C#",
            "source": "var synonyms = new Dictionary<string, IEnumerable<string>>\n{\n    { \"wolverine\", new string[] { \"xmen\", \"logan\" } },\n    { \"logan\", new string[] { \"wolverine\", \"xmen\" } },\n    { \"wow\", new string[] { \"world of warcraft\" } }\n};\nawait client.Index(\"movies\").UpdateSynonymsAsync(synonyms);"
          },
          {
            "lang": "Rust",
            "source": "let mut synonyms = std::collections::HashMap::new();\nsynonyms.insert(String::from(\"wolverine\"), vec![String::from(\"xmen\"), String::from(\"logan\")]);\nsynonyms.insert(String::from(\"logan\"), vec![String::from(\"xmen\"), String::from(\"wolverine\")]);\nsynonyms.insert(String::from(\"wow\"), vec![String::from(\"world of warcraft\")]);\n\nlet task: TaskInfo = client\n  .index(\"movies\")\n  .set_synonyms(&synonyms)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let synonyms: [String: [String]] = [\n    \"wolverine\": [\"xmen\", \"logan\"],\n    \"logan\": [\"wolverine\", \"xmen\"],\n    \"wow\": [\"world of warcraft\"]\n]\nclient.index(\"movies\").updateSynonyms(synonyms) { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset synonyms",
        "description": "Reset an index's synonyms to its default value",
        "operationId": "deletesynonyms",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/movies/settings/synonyms'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').resetSynonyms()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->resetSynonyms();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').reset_synonyms()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").resetSynonymsSettings();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').reset_synonyms"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").ResetSynonyms()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").ResetSynonymsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"movies\")\n  .reset_synonyms()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').resetSynonyms();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").resetSynonyms { (result) in\n    switch result {\n    case .success(let task):\n        print(task)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/typo-tolerance": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get typoTolerance",
        "description": "Get an user defined typoTolerance",
        "operationId": "gettypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "typoTolerance is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TypoSettings"
                },
                "example": {}
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').getTypoTolerance()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->getTypoTolerance();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').get_typo_tolerance()"
          },
          {
            "lang": "Ruby",
            "source": "index('books').typo_tolerance"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").GetTypoTolerance()"
          },
          {
            "lang": "Rust",
            "source": "let typo_tolerance: TypoToleranceSettings = client\n  .index(\"books\")\n  .get_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').getTypoTolerance();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset typoTolerance",
        "description": "Reset an index's typoTolerance to its default value",
        "operationId": "deletetypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').resetTypoTolerance()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->resetTypoTolerance();"
          },
          {
            "lang": "Python",
            "source": "client.index('books').reset_typo_tolerance()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"books\").resetTypoToleranceSettings();"
          },
          {
            "lang": "Ruby",
            "source": "index('books').reset_typo_tolerance"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").ResetTypoTolerance()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"books\").ResetTypoToleranceAsync();"
          },
          {
            "lang": "Rust",
            "source": "let task: TaskInfo = client\n  .index(\"books\")\n  .reset_typo_tolerance()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('books').resetTypoTolerance();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update typoTolerance",
        "description": "Update an index's user defined typoTolerance",
        "operationId": "patchtypoTolerance",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TypoSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/books/settings/typo-tolerance' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"minWordSizeForTypos\": {\n      \"oneTypo\": 4,\n      \"twoTypos\": 10\n    },\n    \"disableOnAttributes\": [\"title\"]\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('books').updateTypoTolerance({\n  minWordSizeForTypos: {\n      oneTypo: 4,\n      twoTypos: 10\n    },\n    disableOnAttributes: [\n      'title'\n  ]\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->index('books')->updateTypoTolerance([\n  'minWordSizeForTypos' => [\n      'oneTypo' => 4,\n      'twoTypos' => 10\n    ],\n    'disableOnAttributes' => [\n      'title'\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.index('books').update_typo_tolerance({\n  'minWordSizeForTypos': {\n      'oneTypo': 4,\n      'twoTypos': 10\n    },\n    'disableOnAttributes': [\n       'title'\n    ]\n})"
          },
          {
            "lang": "Java",
            "source": "TypoTolerance typoTolerance = new TypoTolerance();\nHashMap<String, Integer> minWordSizeTypos =\n        new HashMap<String, Integer>() {\n            {\n                put(\"oneTypo\", 4);\n                put(\"twoTypos\", 10);\n            }\n        };\n\ntypoTolerance.setMinWordSizeForTypos(minWordSizeTypos);\ntypoTolerance.setDisableOnAttributes(new String[] {\"title\"});\n\nclient.index(\"books\").updateTypoToleranceSettings(typoTolerance);"
          },
          {
            "lang": "Ruby",
            "source": "index('books').update_typo_tolerance({\n  min_word_size_for_typos: {\n    one_typo: 4,\n    two_typos: 10\n  },\n  disable_on_attributes: ['title']\n})"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"books\").UpdateTypoTolerance(&meilisearch.TypoTolerance{\n  MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{\n      OneTypo: 4,\n      TwoTypos: 10,\n    },\n    DisableOnAttributes: []string{\"title\"},\n})"
          },
          {
            "lang": "C#",
            "source": "var typoTolerance = new TypoTolerance {\n  DisableOnAttributes = new string[] { \"title\" },\n  MinWordSizeTypos = new TypoTolerance.TypoSize {\n      OneTypo = 4,\n      TwoTypos = 10\n  }\n};\n\nawait client.Index(\"books\").UpdateTypoToleranceAsync(typoTolerance);"
          },
          {
            "lang": "Rust",
            "source": "let typo_tolerance = TypoToleranceSettings {\n  enabled: Some(false),\n  disable_on_attributes: None,\n  disable_on_words: None,\n  min_word_size_for_typos: None,\n};\n\nlet task: TaskInfo = client\n  .index(\"books\")\n  .set_typo_tolerance(&typo_tolerance)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "final toUpdate = TypoTolerance(\n  minWordSizeForTypos: MinWordSizeForTypos(\n    oneTypo: 4,\n    twoTypos: 10,\n  ),\n  disableOnAttributes: ['title'],\n);\nawait client.index('books').updateTypoTolerance(toUpdate);"
          }
        ]
      }
    },
    "/indexes/{indexUid}/settings/vector-store": {
      "get": {
        "tags": [
          "Settings"
        ],
        "summary": "Get vectorStore",
        "description": "Get an user defined vectorStore",
        "operationId": "getvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "vectorStore is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VectorStoreBackend"
                },
                "example": "stable"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.get",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Settings"
        ],
        "summary": "Reset vectorStore",
        "description": "Reset an index's vectorStore to its default value",
        "operationId": "deletevectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store'"
          }
        ]
      },
      "patch": {
        "tags": [
          "Settings"
        ],
        "summary": "Update vectorStore",
        "description": "Update an index's user defined vectorStore",
        "operationId": "patchvectorStore",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/VectorStoreBackend"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": "movies",
                  "status": "enqueued",
                  "type": "settingsUpdate",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "settings.update",
              "settings.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/indexes/INDEX_UID/settings/vector-store' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '\"experimental\"'"
          }
        ]
      }
    },
    "/indexes/{indexUid}/similar": {
      "get": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with GET",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_get",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          },
          {
            "name": "id",
            "in": "query",
            "description": "The unique identifier (primary key value) of the target document.\nMeilisearch will find and return documents that are semantically\nsimilar to this document based on their vector embeddings. This is a\nrequired parameter.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "Number of similar documents to skip in the response. Use together with\n`limit` for pagination through large result sets. For example, to get\nsimilar documents 21-40, set `offset=20` and `limit=20`. Defaults to\n`0`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of similar documents to return in a single response. Use\ntogether with `offset` for pagination. Higher values return more\nresults but may increase response time. Defaults to `20`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          },
          {
            "name": "attributes_to_retrieve",
            "in": "query",
            "description": "Comma-separated list of document attributes to include in the response.\nUse `*` to retrieve all attributes. By default, all attributes listed\nin the `displayedAttributes` setting are returned. Example:\n`title,description,price`.",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "retrieve_vectors",
            "in": "query",
            "description": "When `true`, includes the vector embeddings for each returned document.\nUseful for debugging or when you need to inspect the vector data. Note\nthat this can significantly increase response size. Defaults to\n`false`.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "filter",
            "in": "query",
            "description": "Filter expression to narrow down which documents can be returned as\nsimilar. Uses the same syntax as search filters. Only documents\nmatching this filter will be considered when finding similar documents.\nExample: `genres = action AND year > 2000`.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "show_ranking_score",
            "in": "query",
            "description": "When `true`, includes a global `_rankingScore` field in each document\nshowing how similar it is to the target document. The score is a value\nbetween 0 and 1, where higher values indicate greater similarity.\nDefaults to `false`.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "show_ranking_score_details",
            "in": "query",
            "description": "When `true`, includes a detailed `_rankingScoreDetails` object in each\ndocument breaking down how the similarity score was calculated. Useful\nfor debugging and understanding why certain documents are considered\nmore similar. Defaults to `false`.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "show_performance_details",
            "in": "query",
            "description": "When `true`, includes a `_performanceDetails` object showing the\nperformance details of the search.",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "ranking_score_threshold",
            "in": "query",
            "description": "Minimum ranking score threshold (between 0.0 and 1.0) that documents\nmust meet to be included in results. Documents with a similarity score\nbelow this threshold will be excluded. Useful for ensuring only highly\nsimilar documents are returned.",
            "required": false,
            "schema": {
              "type": "number",
              "format": "float"
            }
          },
          {
            "name": "embedder",
            "in": "query",
            "description": "The name of the embedder to use for finding similar documents. This\nmust match one of the embedders configured in your index settings. The\nembedder determines how document similarity is calculated based on\nvector embeddings.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "id": "143",
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/INDEX_NAME/similar?id=TARGET_DOCUMENT_ID&embedder=EMBEDDER_NAME'"
          }
        ]
      },
      "post": {
        "tags": [
          "Similar documents"
        ],
        "summary": "Get similar documents with POST",
        "description": "Retrieve documents similar to a specific search result.",
        "operationId": "similar_post",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SimilarQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The documents are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SimilarResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 2770,
                      "title": "American Pie 2",
                      "poster": "https://image.tmdb.org/t/p/w1280/q4LNgUnRfltxzp3gf1MAGiK5LhV.jpg",
                      "overview": "The whole gang are back and as close as ever. They decide to get even closer by spending the summer together at a beach house. They decide to hold the biggest",
                      "release_date": 997405200
                    },
                    {
                      "id": 190859,
                      "title": "American Sniper",
                      "poster": "https://image.tmdb.org/t/p/w1280/svPHnYE7N5NAGO49dBmRhq0vDQ3.jpg",
                      "overview": "U.S. Navy SEAL Chris Kyle takes his sole missionprotect his comradesto heart and becomes one of the most lethal snipers in American history. His pinpoint accuracy not only saves countless lives but also makes him a prime",
                      "release_date": 1418256000
                    }
                  ],
                  "id": "143",
                  "offset": 0,
                  "limit": 2,
                  "estimatedTotalHits": 976,
                  "processingTimeMs": 35
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/indexes/INDEX_NAME/similar' \\\n  -H 'Content-Type: application/json' \\\n  -H 'Authorization: Bearer DEFAULT_SEARCH_API_KEY' \\\n  --data-binary '{\n    \"id\": TARGET_DOCUMENT_ID,\n    \"embedder\": \"EMBEDDER_NAME\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.index('INDEX_NAME').searchSimilarDocuments({ id: 'TARGET_DOCUMENT_ID', embedder: 'default' })"
          },
          {
            "lang": "PHP",
            "source": "$similarQuery = new SimilarDocumentsQuery('TARGET_DOCUMENT_ID', 'default');\n$client->index('INDEX_NAME')->searchSimilarDocuments($similarQuery);"
          },
          {
            "lang": "Python",
            "source": "client.index(\"INDEX_NAME\").get_similar_documents({\"id\": \"TARGET_DOCUMENT_ID\", \"embedder\": \"default\"})"
          },
          {
            "lang": "Ruby",
            "source": "client.index('INDEX_NAME').search_similar_documents('TARGET_DOCUMENT_ID', embedder: 'default')"
          },
          {
            "lang": "Go",
            "source": "resp := new(meilisearch.SimilarDocumentResult)\nclient.Index(\"INDEX_NAME\").SearchSimilarDocuments(&meilisearch.SimilarDocumentQuery{\n  Id: \"TARGET_DOCUMENT_ID\",\n  Embedder: \"default\",\n}, resp)"
          },
          {
            "lang": "Rust",
            "source": "let results = index\n  .similar_search(\"TARGET_DOCUMENT_ID\", \"EMBEDDER_NAME\")\n  .execute()\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/indexes/{indexUid}/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of index",
        "description": "Get the stats of an index.",
        "operationId": "get_index_stats",
        "parameters": [
          {
            "name": "indexUid",
            "in": "path",
            "description": "Index Unique Identifier",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "movies"
          }
        ],
        "responses": {
          "200": {
            "description": "The stats of the index",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/IndexStats"
                },
                "example": {
                  "numberOfDocuments": 10,
                  "rawDocumentDbSize": 10,
                  "avgDocumentSize": 10,
                  "numberOfEmbeddings": 10,
                  "numberOfEmbeddedDocuments": 10,
                  "isIndexing": true,
                  "fieldDistribution": {
                    "genre": 10,
                    "author": 9
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "Index not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Index `movies` not found.",
                  "code": "index_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#index_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/indexes/movies/stats'"
          },
          {
            "lang": "JS",
            "source": "client.index('movies').getStats()"
          },
          {
            "lang": "PHP",
            "source": "$client->index('movies')->stats();"
          },
          {
            "lang": "Python",
            "source": "client.index('movies').get_stats()"
          },
          {
            "lang": "Java",
            "source": "client.index(\"movies\").getStats();"
          },
          {
            "lang": "Ruby",
            "source": "client.index('movies').stats"
          },
          {
            "lang": "Go",
            "source": "client.Index(\"movies\").GetStats()"
          },
          {
            "lang": "C#",
            "source": "await client.Index(\"movies\").GetStatsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let stats: IndexStats = client\n  .index(\"movies\")\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.index('movies').getStats();"
          },
          {
            "lang": "Swift",
            "source": "client.index(\"movies\").stats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/keys": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "List API keys",
        "description": "List all API keys",
        "operationId": "list_api_keys",
        "parameters": [
          {
            "name": "offset",
            "in": "query",
            "description": "Number of API keys to skip in the response. Use together with `limit`\nfor pagination through large sets of keys. For example, to get keys\n21-40, set `offset=20` and `limit=20`. Defaults to `0`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 0,
              "minimum": 0
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of API keys to return in a single response. Use together\nwith `offset` for pagination. Defaults to `20`.",
            "required": true,
            "schema": {
              "type": "integer",
              "default": 20,
              "minimum": 0
            }
          }
        ],
        "responses": {
          "202": {
            "description": "List of keys",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginationView_KeyView"
                },
                "example": {
                  "results": [
                    {
                      "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                      "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                      "name": "An API Key",
                      "description": null,
                      "actions": [
                        "documents.add"
                      ],
                      "indexes": [
                        "movies"
                      ],
                      "expiresAt": "2022-11-12T10:00:00Z",
                      "createdAt": "2021-11-12T10:00:00Z",
                      "updatedAt": "2021-11-12T10:00:00Z"
                    }
                  ],
                  "limit": 20,
                  "offset": 0,
                  "total": 1
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys?limit=3' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "JS",
            "source": "client.getKeys({ limit: 3 })"
          },
          {
            "lang": "PHP",
            "source": "$client->getKeys((new KeysQuery())->setLimit(3));"
          },
          {
            "lang": "Python",
            "source": "client.get_keys({'limit': 3})"
          },
          {
            "lang": "Java",
            "source": "KeysQuery query = new KeysQuery().setLimit(3);\nclient.getKeys(query);"
          },
          {
            "lang": "Ruby",
            "source": "client.keys(limit: 3)"
          },
          {
            "lang": "Go",
            "source": "client.GetKeys(&meilisearch.KeysQuery{\n  Limit: 3\n});"
          },
          {
            "lang": "C#",
            "source": "ResourceResults<Key> keyResult = await client.GetKeysAsync(new KeysQuery { Limit = 3 });"
          },
          {
            "lang": "Rust",
            "source": "let mut query = KeysQuery::new()\n  .with_limit(3)\n  .execute(&client)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getKeys(params: KeysQuery(limit: 3));\neate_a_key_1: \"await client.createKey(\\n    description: 'Add documents: Products API key',\\n    actions: ['documents.add'],\\n    indexes: ['products'],\\n    expiresAt: DateTime(2042, 04, 02));\"\ndate_a_key_1: \"await client.updateKey(\\n  '6062abda-a5aa-4414-ac91-ecd7944c0f8d',\\n  description: 'Manage documents: Products\\/Reviews API key',\\n  name: 'Products\\/Reviews API key',\\n);\""
          },
          {
            "lang": "Swift",
            "source": "client.getKeys(params: KeysQuery(limit: 3)) { result in\n    switch result {\n    case .success(let keys):\n        print(keys)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "post": {
        "tags": [
          "Keys"
        ],
        "summary": "Create API key",
        "description": "Create an API Key.",
        "operationId": "create_api_key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Key has been created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "Indexing Products API key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "products"
                  ],
                  "expiresAt": "2021-11-13T00:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.create",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/keys' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"description\": \"Add documents: Products API key\",\n    \"actions\": [\"documents.add\"],\n    \"indexes\": [\"products\"],\n    \"expiresAt\": \"2042-04-02T00:42:42Z\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.createKey({\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expiresAt: '2021-11-13T00:00:00Z'\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->createKey([\n  'description' => 'Add documents: Products API key',\n  'actions' => ['documents.add'],\n  'indexes' => ['products'],\n  'expiresAt' => '2042-04-02T00:42:42Z',\n]);"
          },
          {
            "lang": "Python",
            "source": "client.create_key(options={\n  'description': 'Add documents: Products API key',\n  'actions': ['documents.add'],\n  'indexes': ['products'],\n  'expiresAt': '2042-04-02T00:42:42Z'\n})"
          },
          {
            "lang": "Java",
            "source": "SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\nDate dateParsed = format.parse(\"2042-04-02T00:42:42Z\");\n\nKey keyInfo = new Key();\n\nkeyInfo.setDescription(\"Add documents: Products API key\");\nkeyInfo.setActions(new String[] {\"documents.add\"});\nkeyInfo.setIndexes(new String[] {\"products\"});\nkeyInfo.setExpiresAt(dateParsed);\n\nclient.createKey(keyInfo);"
          },
          {
            "lang": "Ruby",
            "source": "client.create_key(\n  description: 'Add documents: Products API key',\n  actions: ['documents.add'],\n  indexes: ['products'],\n  expires_at: '2042-04-02T00:42:42Z'\n)"
          },
          {
            "lang": "Go",
            "source": "client.CreateKey(&meilisearch.Key{\n  Description: \"Add documents: Products API key\",\n  Actions: []string{\"documents.add\"},\n  Indexes: []string{\"products\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "C#",
            "source": "Key keyOptions = new Key\n{\n    Description = \"Add documents: Products API key\",\n    Actions = new KeyAction[] { KeyAction.DocumentsAdd },\n    Indexes = new string[] { \"products\" },\n    ExpiresAt = DateTime.Parse(\"2042-04-02T00:42:42Z\")\n};\nKey createdKey = await this.client.CreateKeyAsync(keyOptions);"
          },
          {
            "lang": "Rust",
            "source": "let mut key_options = KeyBuilder::new();\nkey_options\n  .with_name(\"Add documents: Products API key\")\n  .with_action(Action::DocumentsAdd)\n  .with_expires_at(time::macros::datetime!(2042 - 04 - 02 00:42:42 UTC))\n  .with_index(\"products\");\nlet new_key = client\n  .create_key(key_options)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let keyParams = KeyParams(\n  description: \"Add documents: Products API key\",\n  actions: [\"documents.add\"],\n  indexes: [\"products\"],\n  expiresAt: \"2042-04-02T00:42:42Z\"\n)\nclient.createKey(keyParams) { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/keys/{uidOrKey}": {
      "get": {
        "tags": [
          "Keys"
        ],
        "summary": "Get API key",
        "description": "Get an API key from its `uid` or its `key` field.",
        "operationId": "get_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "200": {
            "description": "The key is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.get",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "JS",
            "source": "client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "PHP",
            "source": "$client->getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Python",
            "source": "client.get_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Java",
            "source": "client.getKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\");"
          },
          {
            "lang": "Ruby",
            "source": "client.key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Go",
            "source": "client.GetKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "C#",
            "source": "Key key = await client.GetKeyAsync(\"d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4\");"
          },
          {
            "lang": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Swift",
            "source": "client.getKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success(let key):\n        print(key)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Keys"
        ],
        "summary": "Delete API key",
        "description": "Delete the specified API key.",
        "operationId": "delete_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "responses": {
          "204": {
            "description": "The key have been removed"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.delete",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY'"
          },
          {
            "lang": "JS",
            "source": "client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Python",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Java",
            "source": "client.deleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_key('6062abda-a5aa-4414-ac91-ecd7944c0f8d')"
          },
          {
            "lang": "Go",
            "source": "client.DeleteKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "C#",
            "source": "client.DeleteKeyAsync(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")"
          },
          {
            "lang": "Rust",
            "source": "let key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nclient\n  .delete_key(&key)\n  .await?;\nthorization_header_1:\nlet client = Client::new(\"http://localhost:7700\", Some(\"masterKey\"));\nlet keys = client\n.get_keys()\n.await\n.unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.deleteKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d');"
          },
          {
            "lang": "Swift",
            "source": "client.deleteKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\") { result in\n    switch result {\n    case .success:\n        print(\"success\")\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "patch": {
        "tags": [
          "Keys"
        ],
        "summary": "Update API key",
        "description": "Update the name and description of an API key. Updates to keys are partial.\nThis means you should provide only the fields you intend to update, as any\nfields not present in the payload will remain unchanged.",
        "operationId": "patch_api_key",
        "parameters": [
          {
            "name": "uidOrKey",
            "in": "path",
            "description": "The `uid` or `key` field of an existing API key",
            "required": true,
            "schema": {
              "type": "string",
              "format": "password"
            },
            "example": "7b198a7f-52a0-4188-8762-9ad93cd608b2"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchApiKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The key have been updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/KeyView"
                },
                "example": {
                  "uid": "01b4bc42-eb33-4041-b481-254d00cce834",
                  "key": "d0552b41536279a0ad88bd595327b96f01176a60c2243e906c52ac02375f9bc4",
                  "name": "An API Key",
                  "description": null,
                  "actions": [
                    "documents.add"
                  ],
                  "indexes": [
                    "movies"
                  ],
                  "expiresAt": "2022-11-12T10:00:00Z",
                  "createdAt": "2021-11-12T10:00:00Z",
                  "updatedAt": "2021-11-12T10:00:00Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "keys.update",
              "keys.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/keys/6062abda-a5aa-4414-ac91-ecd7944c0f8d' \\\n  -H 'Authorization: Bearer MASTER_KEY' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"name\": \"Products/Reviews API key\",\n    \"description\": \"Manage documents: Products/Reviews API key\"\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d', {\n    name: 'Products/Reviews API key',\n    description: 'Manage documents: Products/Reviews API key',\n})"
          },
          {
            "lang": "PHP",
            "source": "$client->updateKey('6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  [\n    'name' => 'Products/Reviews API key',\n    'description' => 'Manage documents: Products/Reviews API key'\n  ]);"
          },
          {
            "lang": "Python",
            "source": "client.update_key(key_or_uid='6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  options={\n    'name': 'Products/Reviews API key',\n    'description': 'Manage documents: Products/Reviews API key'\n})"
          },
          {
            "lang": "Java",
            "source": "KeyUpdate keyChanges = new KeyUpdate();\nkeyChanges.setName(\"Products/Reviews API key\");\nkeyChanges.setDescription(\"Manage documents: Products/Reviews API key\");\n\nclient.updateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyChanges);"
          },
          {
            "lang": "Ruby",
            "source": "client.update_key(\n  '6062abda-a5aa-4414-ac91-ecd7944c0f8d',\n  {\n    description: 'Manage documents: Products/Reviews API key',\n    name: 'Products/Reviews API key'\n  }\n)"
          },
          {
            "lang": "Go",
            "source": "client.UpdateKey(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", &meilisearch.Key{\n  Description: \"Manage documents: Products/Reviews API key\",\n  Actions: []string{\"documents.add\", \"document.delete\"},\n  Indexes: []string{\"products\", \"reviews\"},\n  ExpiresAt: time.Date(2042, time.April, 02, 0, 42, 42, 0, time.UTC),\n})"
          },
          {
            "lang": "C#",
            "source": "await client.UpdateKeyAsync(\n  \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\",\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)"
          },
          {
            "lang": "Rust",
            "source": "let mut key = client\n  .get_key(\"6062abda-a5aa-4414-ac91-ecd7944c0f8d\")\n  .await\n  .unwrap();\nkey\n    .with_description(\"Manage documents: Products/Reviews API key\".to_string())\n    .with_name(\"Products/Reviews API key\".to_string())\n    .update(&client)\n    .await\n    .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let keyParams = KeyUpdateParams(\n  description: \"Manage documents: Products/Reviews API key\",\n  name: \"Products/Reviews API key\"\n)\n\nclient.updateKey(keyOrUid: \"6062abda-a5aa-4414-ac91-ecd7944c0f8d\", keyParams: keyParams) { result in\n  switch result {\n  case .success(let key):\n      print(key)\n  case .failure(let error):\n      print(error)\n  }\n}"
          }
        ]
      }
    },
    "/logs/stderr": {
      "post": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Update target of the console logs",
        "description": "This route lets you specify at runtime the level of the console logs\noutputted on stderr.",
        "operationId": "update_stderr_target",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateStderrLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "The console logs have been updated"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/logs/stderr \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n      \"target\": \"milli=trace,index_scheduler=info,actix_web=off\"\n  }'"
          }
        ]
      }
    },
    "/logs/stream": {
      "post": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Retrieve logs",
        "description": "Stream logs over HTTP. The format of the logs depends on the\nconfiguration specified in the payload. The logs are sent as multi-part,\nand the stream never stops, so make sure your clients correctly handle\nthat. To make the server stop sending you logs, you can call the `DELETE\n/logs/stream` route.\n\nThere can only be one listener at a timeand an error will be returned if\nyou call this route while it's being used by another client.",
        "operationId": "get_logs",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GetLogs"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Logs are being returned",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                },
                "example": "\n2024-10-08T13:35:02.643750Z  WARN HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: tracing_actix_web::middleware: Error encountered while processing the incoming HTTP request: ResponseError { code: 400, message: \"Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625\", error_code: \"feature_not_enabled\", error_type: \"invalid_request\", error_link: \"https://docs.meilisearch.com/errors#feature_not_enabled\" }\n2024-10-08T13:35:02.644191Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=400 error=Getting metrics requires enabling the `metrics` experimental feature. See https://github.com/meilisearch/product/discussions/625}: meilisearch: close time.busy=1.66ms time.idle=658s\n2024-10-08T13:35:18.564152Z  INFO HTTP request{method=PATCH host=\"localhost:7700\" route=/experimental-features query_parameters= user_agent=curl/8.6.0 status_code=200}: meilisearch: close time.busy=1.17ms time.idle=127s\n2024-10-08T13:35:23.094987Z  INFO HTTP request{method=GET host=\"localhost:7700\" route=/metrics query_parameters= user_agent=HTTPie/3.2.3 status_code=200}: meilisearch: close time.busy=2.12ms time.idle=595s\n"
              }
            }
          },
          "400": {
            "description": "The route is already being used",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The `/logs/stream` route is currently in use by someone else.",
                  "code": "bad_request",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#bad_request"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST MEILISEARCH_URL/logs/stream \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"mode\": \"human\",\n    \"target\": \"index_scheduler=trace\"\n  }'"
          }
        ]
      },
      "delete": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Stop retrieving logs",
        "description": "Call this route to make the engine stops sending logs through the `POST\n/logs/stream` route.",
        "operationId": "cancel_logs",
        "responses": {
          "204": {
            "description": "Logs are being returned"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE MEILISEARCH_URL/logs/stream\n}'"
          }
        ]
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get prometheus metrics",
        "description": "Retrieve metrics on the engine. See https://www.meilisearch.com/docs/learn/experimental/metrics\nCurrently, [the feature is experimental](https://www.meilisearch.com/docs/learn/experimental/overview)\nwhich means it must be enabled.",
        "operationId": "get_metrics",
        "responses": {
          "200": {
            "description": "The metrics of the instance",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string"
                },
                "example": "\n# HELP meilisearch_db_size_bytes Meilisearch DB Size In Bytes\n# TYPE meilisearch_db_size_bytes gauge\nmeilisearch_db_size_bytes 1130496\n# HELP meilisearch_batch_running_progress_trace The currently running progress trace\n# TYPE meilisearch_batch_running_progress_trace gauge\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"document\"} 0.710618582519409\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"extracting word proximity\"} 0.2222222222222222\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"indexing\"} 0.6666666666666666\nmeilisearch_batch_running_progress_trace{batch_uid=\"0\",step_name=\"processing tasks\"} 0\n# HELP meilisearch_http_requests_total Meilisearch HTTP requests total\n# TYPE meilisearch_http_requests_total counter\nmeilisearch_http_requests_total{method=\"GET\",path=\"/metrics\",status=\"400\"} 1\nmeilisearch_http_requests_total{method=\"PATCH\",path=\"/experimental-features\",status=\"200\"} 1\n# HELP meilisearch_http_response_time_seconds Meilisearch HTTP response times\n# TYPE meilisearch_http_response_time_seconds histogram\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.005\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.01\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.025\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.05\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.075\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.25\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"0.75\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"1\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"2.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"7.5\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"10\"} 0\nmeilisearch_http_response_time_seconds_bucket{method=\"GET\",path=\"/metrics\",le=\"+Inf\"} 0\nmeilisearch_http_response_time_seconds_sum{method=\"GET\",path=\"/metrics\"} 0\nmeilisearch_http_response_time_seconds_count{method=\"GET\",path=\"/metrics\"} 0\n# HELP meilisearch_last_finished_batches_progress_trace_ms The last few batches progress trace in milliseconds\n# TYPE meilisearch_last_finished_batches_progress_trace_ms gauge\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks\"} 19360\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes\"} 368\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > computing document changes > preparing payloads > payload\"} 367\nmeilisearch_last_finished_batches_progress_trace_ms{batch_uid=\"0\",step_name=\"processing tasks > indexing\"} 18970\n# HELP meilisearch_index_count Meilisearch Index Count\n# TYPE meilisearch_index_count gauge\nmeilisearch_index_count 1\n# HELP meilisearch_index_docs_count Meilisearch Index Docs Count\n# TYPE meilisearch_index_docs_count gauge\nmeilisearch_index_docs_count{index=\"mieli\"} 2\n# HELP meilisearch_is_indexing Meilisearch Is Indexing\n# TYPE meilisearch_is_indexing gauge\nmeilisearch_is_indexing 0\n# HELP meilisearch_last_update Meilisearch Last Update\n# TYPE meilisearch_last_update gauge\nmeilisearch_last_update 1726675964\n# HELP meilisearch_nb_tasks Meilisearch Number of tasks\n# TYPE meilisearch_nb_tasks gauge\nmeilisearch_nb_tasks{kind=\"indexes\",value=\"mieli\"} 39\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"canceled\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"enqueued\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"failed\"} 4\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"processing\"} 0\nmeilisearch_nb_tasks{kind=\"statuses\",value=\"succeeded\"} 35\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentAdditionOrUpdate\"} 9\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentDeletion\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"documentEdition\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"dumpCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexDeletion\"} 8\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexSwap\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"indexUpdate\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"settingsUpdate\"} 22\nmeilisearch_nb_tasks{kind=\"types\",value=\"snapshotCreation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskCancelation\"} 0\nmeilisearch_nb_tasks{kind=\"types\",value=\"taskDeletion\"} 0\n# HELP meilisearch_used_db_size_bytes Meilisearch Used DB Size In Bytes\n# TYPE meilisearch_used_db_size_bytes gauge\nmeilisearch_used_db_size_bytes 409600\n"
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "metrics.get",
              "metrics.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/metrics'"
          }
        ]
      }
    },
    "/multi-search": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Perform a multi-search",
        "description": "Bundle multiple search queries in a single API request. Use this endpoint\nto search through multiple indexes at once.",
        "operationId": "multi_search_with_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FederatedSearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Federated multi-search",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FederatedSearchResult"
                },
                "example": {
                  "hits": [
                    {
                      "id": 42,
                      "title": "Batman returns",
                      "overview": "The overview of batman returns",
                      "_federation": {
                        "indexUid": "movies",
                        "queriesPosition": 0
                      }
                    },
                    {
                      "comicsId": "batman-killing-joke",
                      "description": "This comic is really awesome",
                      "title": "Batman: the killing joke",
                      "_federation": {
                        "indexUid": "comics",
                        "queriesPosition": 1
                      }
                    }
                  ],
                  "processingTimeMs": 0,
                  "limit": 20,
                  "offset": 0,
                  "estimatedTotalHits": 2,
                  "semanticHitCount": 0
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/multi-search' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"queries\": [\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"pooh\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movies\",\n        \"q\": \"nemo\",\n        \"limit\": 5\n      },\n      {\n        \"indexUid\": \"movie_ratings\",\n        \"q\": \"us\"\n      }\n    ]\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.multiSearch({ queries: [\n  {\n    indexUid: 'movies',\n    q: 'pooh',\n    limit: 5,\n  },\n  {\n    indexUid: 'movies',\n    q: 'nemo',\n    limit: 5,\n  },\n  {\n    indexUid: 'movie_ratings',\n    q: 'us',\n  },\n]})"
          },
          {
            "lang": "PHP",
            "source": "$client->multiSearch([\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('pooh')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movies')\n        ->setQuery('nemo')\n        ->setLimit(5),\n    (new SearchQuery())\n        ->setIndexUid('movie_ratings')\n        ->setQuery('us')\n  ]);"
          },
          {
            "lang": "Python",
            "source": "client.multi_search(\n  [\n    {'indexUid': 'movies', 'q': 'pooh', 'limit': 5},\n    {'indexUid': 'movies', 'q': 'nemo', 'limit': 5},\n    {'indexUid': 'movie_ratings', 'q': 'us'}\n  ]\n)"
          },
          {
            "lang": "Java",
            "source": "MultiSearchRequest multiSearchRequest = new MultiSearchRequest();\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"pooh\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movies\").setQuery(\"nemo\").setLimit(5));\nmultiIndexSearch.addQuery(new IndexSearchRequest(\"movie_ratings\").setQuery(\"us\"));\n\nclient.multiSearch(multiSearchRequest);\nt_similar_post_1:\nSimilarDocumentRequest query = new SimilarDocumentRequest()\n  .setId(\"143\")\n  .setEmbedder(\"manual\");\nclient.index(\"movies\").searchSimilarDocuments(query)"
          },
          {
            "lang": "Ruby",
            "source": "client.multi_search([\n  { index_uid: 'books', q: 'prince' },\n  { index_uid: 'movies', q: 'pooh', limit: 5 }\n  { index_uid: 'movies', q: 'nemo', limit: 5 }\n  { index_uid: 'movie_ratings', q: 'us' }\n])"
          },
          {
            "lang": "Go",
            "source": "client.MultiSearch(&MultiSearchRequest{\n  Queries: []SearchRequest{\n    {\n      IndexUID: \"movies\",\n      Query:    \"pooh\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movies\",\n      Query:    \"nemo\",\n      Limit:    5,\n    },\n    {\n      IndexUID: \"movie_ratings\",\n      Query:    \"us\",\n    },\n  },\n})"
          },
          {
            "lang": "C#",
            "source": "await client.MultiSearchAsync(new MultiSearchQuery()\n{\n    Queries = new System.Collections.Generic.List<SearchQuery>()\n    {\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"booh\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movies\",\n          Q = \"nemo\",\n          Limit = 5\n        },\n        new SearchQuery() {\n          IndexUid = \"movie_ratings\",\n          Q = \"us\",\n        },\n    }\n});"
          },
          {
            "lang": "Rust",
            "source": "let movie = client.index(\"movie\");\nlet movie_ratings = client.index(\"movie_ratings\");\n\nlet search_query_1 = SearchQuery::new(&movie)\n    .with_query(\"pooh\")\n    .with_limit(5)\n    .build();\nlet search_query_2 = SearchQuery::new(&movie)\n    .with_query(\"nemo\")\n    .with_limit(5)\n    .build();\nlet search_query_3 = SearchQuery::new(&movie_ratings)\n    .with_query(\"us\")\n    .build();\n\nlet response = client\n    .multi_search()\n    .with_search_query(search_query_1)\n    .with_search_query(search_query_2)\n    .with_search_query(search_query_3)\n    .execute::<Document>()\n    .await\n    .unwrap();"
          }
        ]
      }
    },
    "/network": {
      "get": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Get network topology",
        "description": "Get a list of all Meilisearch instances currently known to this instance.",
        "operationId": "get_network",
        "responses": {
          "200": {
            "description": "Known nodes are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/network'"
          },
          {
            "lang": "PHP",
            "source": "$client->getNetwork();"
          },
          {
            "lang": "Python",
            "source": "client.get_all_networks()"
          },
          {
            "lang": "Go",
            "source": "client.GetNetwork();"
          },
          {
            "lang": "Rust",
            "source": "let network = client\n  .get_network_state()\n  .await\n  .unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Experimental features"
        ],
        "summary": "Configure network topology",
        "description": "Add or remove nodes from network.",
        "operationId": "patch_network",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Network"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "New network state is returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Network"
                },
                "example": {
                  "self": "ms-0",
                  "remotes": {
                    "ms-0": {
                      "url": "http://localhost:7700",
                      "searchApiKey": null,
                      "writeApiKey": null
                    },
                    "ms-1": {
                      "url": "http://localhost:7701",
                      "searchApiKey": "foo",
                      "writeApiKey": "bar"
                    },
                    "ms-2": {
                      "url": "http://localhost:7702",
                      "searchApiKey": "bar",
                      "writeApiKey": "foo"
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "network.update",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/network' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"self\": \"ms-00\",\n    \"remotes\": {\n      \"ms-00\": {\n        \"url\": \"http://INSTANCE_URL\",\n        \"searchApiKey\": \"INSTANCE_API_KEY\"\n      },\n      \"ms-01\": {\n        \"url\": \"http://ANOTHER_INSTANCE_URL\",\n        \"searchApiKey\": \"ANOTHER_INSTANCE_API_KEY\"\n      }\n    }\n  }'"
          },
          {
            "lang": "PHP",
            "source": "$client->updateNetwork([\n  'self' => 'ms-00',\n  'leader' => 'ms-00',\n  'remotes' => [\n    'ms-00' => [\n      'url' => 'http://INSTANCE_URL',\n      'searchApiKey' => 'INSTANCE_API_KEY',\n      'writeApiKey' => 'INSTANCE_WRITE_API_KEY'\n    ],\n    'ms-01' => [\n      'url' => 'http://ANOTHER_INSTANCE_URL',\n      'searchApiKey' => 'ANOTHER_INSTANCE_API_KEY',\n      'writeApiKey' => 'ANOTHER_INSTANCE_WRITE_API_KEY'\n    ]\n  ]\n]);"
          },
          {
            "lang": "Python",
            "source": "client.add_or_update_networks({\n    \"remotes\": {\n        \"http://localhost:7700\": {\n            \"searchApiKey\": \"masterKey\"\n        }\n    },\n    \"leader\": None\n})"
          },
          {
            "lang": "Go",
            "source": "client.UpdateNetwork(&meilisearch.UpdateNetworkRequest{\n  Self: meilisearch.String(\"ms-00\"),\n  Leader: meilisearch.String(\"ms-00\"),\n  Remotes: meilisearch.NewOpt(map[string]meilisearch.Opt[meilisearch.Remote]{\n    \"ms-00\": meilisearch.NewOpt(meilisearch.Remote{\n      URL:          meilisearch.String(\"https://meilisearch.com\"),\n      SearchAPIKey: meilisearch.String(\"ReadKey\"),\n      WriteAPIKey: meilisearch.String(\"WriteKey\"),\n    },\n  },\n});"
          },
          {
            "lang": "Rust",
            "source": "let mut remotes = std::collections::HashMap::new();\nremotes.insert(String::from(\"ms-01\"), Some(meilisearch_sdk::network::RemoteConfig {\n  url: \"https://ms-01.enterprise.meilisearch.com\".to_string(),\n  search_api_key: \"SEARCH_API_KEY\".to_string(),\n  write_api_key: Some(\"WRITE_API_KEY\".to_string()),\n}));\n// Remove ms-00 from the topology\nremotes.insert(String::from(\"ms-00\"), None);\n\nlet update = meilisearch_sdk::network::NetworkUpdate {\n  leader: Some(\"ms-01\".to_string()),\n  remotes: Some(remotes),\n  ..meilisearch_sdk::network::NetworkUpdate::default()\n};\n\nlet task: TaskInfo = client\n  .update_network_state(&update)\n  .await\n  .unwrap();"
          }
        ]
      }
    },
    "/snapshots": {
      "post": {
        "tags": [
          "Backups"
        ],
        "summary": "Create snapshot",
        "description": "Triggers a snapshot creation process. Once the process is complete, a snapshot is created in the snapshot directory. If the snapshot directory does not exist yet, it will be created.",
        "operationId": "create_snapshot",
        "responses": {
          "202": {
            "description": "Snapshot is being created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 0,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "snapshotCreation",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "snapshots.create",
              "snapshots.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/snapshots'"
          },
          {
            "lang": "JS",
            "source": "client.createSnapshot()"
          },
          {
            "lang": "PHP",
            "source": "$client->createSnapshot();"
          },
          {
            "lang": "Python",
            "source": "client.create_snapshot()"
          },
          {
            "lang": "Java",
            "source": "client.createSnapshot();"
          },
          {
            "lang": "Ruby",
            "source": "client.create_snapshot"
          },
          {
            "lang": "Go",
            "source": "client.CreateSnapshot()"
          },
          {
            "lang": "C#",
            "source": "await client.CreateSnapshotAsync();"
          },
          {
            "lang": "Rust",
            "source": "client\n  .create_snapshot()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.createSnapshot()"
          }
        ]
      }
    },
    "/stats": {
      "get": {
        "tags": [
          "Stats"
        ],
        "summary": "Get stats of all indexes",
        "description": "Get stats of all indexes.",
        "operationId": "get_stats",
        "responses": {
          "200": {
            "description": "The stats of the instance",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Stats"
                },
                "example": {
                  "databaseSize": 567,
                  "usedDatabaseSize": 456,
                  "lastUpdate": "2019-11-20T09:40:33.711324Z",
                  "indexes": {
                    "movies": {
                      "numberOfDocuments": 10,
                      "rawDocumentDbSize": 100,
                      "maxDocumentSize": 16,
                      "avgDocumentSize": 10,
                      "isIndexing": true,
                      "fieldDistribution": {
                        "genre": 10,
                        "author": 9
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "stats.get",
              "stats.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/stats'"
          },
          {
            "lang": "JS",
            "source": "client.getStats()"
          },
          {
            "lang": "PHP",
            "source": "$client->stats();"
          },
          {
            "lang": "Python",
            "source": "client.get_all_stats()"
          },
          {
            "lang": "Java",
            "source": "client.getStats();"
          },
          {
            "lang": "Ruby",
            "source": "client.stats"
          },
          {
            "lang": "Go",
            "source": "client.GetStats()"
          },
          {
            "lang": "C#",
            "source": "await client.GetStatsAsync();"
          },
          {
            "lang": "Rust",
            "source": "let stats: ClientStats = client\n  .get_stats()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getStats();"
          },
          {
            "lang": "Swift",
            "source": "client.allStats { (result) in\n    switch result {\n    case .success(let stats):\n        print(stats)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/swap-indexes": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Swap indexes",
        "description": "Swap the documents, settings, and task history of two or more indexes.\nYou can only swap indexes in pairs. However, a single request can swap as\nmany index pairs as you wish. Swapping indexes is an atomic transaction:\neither all indexes are successfully swapped, or none are. Swapping indexA\nand indexB will also replace every mention of indexA by indexB and\nvice-versa in the task history. enqueued tasks are left unmodified.",
        "operationId": "swap_indexes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SwapIndexesPayload"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 3,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "indexSwap",
                  "enqueuedAt": "2021-08-12T10:00:00.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "search",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/swap-indexes' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '[\n    {\n      \"indexes\": [\n        \"indexA\",\n        \"indexB\"\n      ]\n    },\n    {\n      \"indexes\": [\n        \"indexX\",\n        \"indexY\"\n      ]\n    }\n  ]'"
          },
          {
            "lang": "JS",
            "source": "client.swapIndexes([\n  { 'indexes': ['indexA', 'indexB'] },\n  { 'indexes': ['indexX', 'indexY'] }\n])"
          },
          {
            "lang": "PHP",
            "source": "$client->swapIndexes([['indexA', 'indexB'], ['indexX', 'indexY']]);"
          },
          {
            "lang": "Python",
            "source": "client.swap_indexes([{'indexes': ['indexA', 'indexB']}, {'indexes': ['indexX', 'indexY']}])"
          },
          {
            "lang": "Java",
            "source": "SwapIndexesParams[] params =\n        new SwapIndexesParams[] {\n            new SwapIndexesParams().setIndexes(new String[] {\"indexA\", \"indexB\"}),\n            new SwapIndexesParams().setIndexes(new String[] {\"indexX\", \"indexY\"})\n        };\nTaskInfo task = client.swapIndexes(params);"
          },
          {
            "lang": "Ruby",
            "source": "client.swap_indexes(['indexA', 'indexB'], ['indexX', 'indexY'])"
          },
          {
            "lang": "Go",
            "source": "client.SwapIndexes([]SwapIndexesParams{\n  {Indexes: []string{\"indexA\", \"indexB\"}},\n  {Indexes: []string{\"indexX\", \"indexY\"}},\n})"
          },
          {
            "lang": "C#",
            "source": "await client.SwapIndexesAsync(new List<IndexSwap> { new IndexSwap(\"indexA\", \"indexB\"), new IndexSwap(\"indexX\", \"indexY\") } });"
          },
          {
            "lang": "Rust",
            "source": "client.swap_indexes([\n  &SwapIndexes {\n    indexes: (\n        \"indexA\".to_string(),\n        \"indexB\".to_string(),\n    ),\n  }, &SwapIndexes {\n    indexes: (\n        \"indexX\".to_string(),\n        \"indexY\".to_string(),\n    ),\n}])"
          },
          {
            "lang": "Swift",
            "source": "let task = try await self.client.swapIndexes([\n  (\"indexA\", \"indexB\"),\n  (\"indexX\", \"indexY\")\n])"
          }
        ]
      }
    },
    "/tasks": {
      "get": {
        "tags": [
          "Async task management"
        ],
        "summary": "List tasks",
        "description": "Get all [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html)",
        "operationId": "get_tasks",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Maximum number of batches to return",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "default": 20,
              "minimum": 0
            },
            "example": 12
          },
          {
            "name": "from",
            "in": "query",
            "description": "`uid` of the first batch returned",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "reverse",
            "in": "query",
            "description": "If `true`, returns results in the reverse order, from oldest to most recent",
            "required": false,
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Permits to filter tasks by their batch uid. By default, when the\n`batchUids` query parameter is not set, all task uids are returned.\nIt's possible to specify several batch uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "example": 12421
          },
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the uids query\nparameter is not set, all task uids are returned. It's possible to\nspecify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them.\nIt's possible to specify several task uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types`\nquery parameter is not set, all task types are returned. It's possible\nto specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "documentAdditionOrUpdate"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses`\nquery parameter is not set, all task statuses are returned. It's\npossible to specify several statuses by separating them with the `,`\ncharacter.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled",
              "enqueued",
              "processing"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when\n`indexUids` query parameter is not set, the tasks of all the indexes\nare returned. It is possible to specify several indexes by separating\nthem with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          }
        ],
        "responses": {
          "200": {
            "description": "Get all tasks",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AllTasks"
                },
                "example": {
                  "results": [
                    {
                      "uid": 144,
                      "indexUid": "mieli",
                      "status": "succeeded",
                      "type": "indexCreation",
                      "canceledBy": null,
                      "details": null,
                      "error": null,
                      "duration": "PT0.009330S",
                      "enqueuedAt": "2024-08-08T09:01:13.348471Z",
                      "startedAt": "2024-08-08T09:01:13.349442Z",
                      "finishedAt": "2024-08-08T09:01:13.358772Z"
                    }
                  ],
                  "total": 1,
                  "limit": 1,
                  "from": 144,
                  "next": null
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks'"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTasks()"
          },
          {
            "lang": "PHP",
            "source": "$client->getTasks();"
          },
          {
            "lang": "Python",
            "source": "client.get_tasks()"
          },
          {
            "lang": "Java",
            "source": "client.getTasks();"
          },
          {
            "lang": "Ruby",
            "source": "client.tasks"
          },
          {
            "lang": "Go",
            "source": "client.GetTasks(nil);"
          },
          {
            "lang": "Rust",
            "source": "let tasks: TasksResults = client\n  .get_tasks()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getTasks();"
          },
          {
            "lang": "Swift",
            "source": "client.getTasks { (result) in\n    switch result {\n    case .success(let tasks):\n        print(tasks)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      },
      "delete": {
        "tags": [
          "Async task management"
        ],
        "summary": "Delete tasks",
        "description": "Delete [tasks](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html) on filter",
        "operationId": "delete_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query\nparameter is not set, all task uids are returned. It's possible to\nspecify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them.\nIt's possible to specify several task uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types`\nquery parameter is not set, all task types are returned. It's possible\nto specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses`\nquery parameter is not set, all task statuses are returned. It's\npossible to specify several statuses by separating them with the `,`\ncharacter.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when\n`indexUids` query parameter is not set, the tasks of all the indexes\nare returned. It is possible to specify several indexes by separating\nthem with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskDeletion",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to delete are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.delete",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/tasks?uids=1,2'"
          },
          {
            "lang": "JS",
            "source": "client.tasks.deleteTasks({ uids: [1, 2] })"
          },
          {
            "lang": "PHP",
            "source": "$client->deleteTasks((new DeleteTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "Python",
            "source": "client.delete_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "Java",
            "source": "DeleteTasksQuery query = new DeleteTasksQuery().setUids(new int[] {1, 2})\nclient.deleteTasks(query);"
          },
          {
            "lang": "Ruby",
            "source": "client.delete_tasks(uids: [1, 2])"
          },
          {
            "lang": "Go",
            "source": "client.DeleteTaks(&meilisearch.DeleteTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "C#",
            "source": "await client.DeleteTasksAsync(new DeleteTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "Rust",
            "source": "let mut query = tasks::TasksDeleteQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.delete_tasks_with(&query).await.unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.deleteTasks(params: DeleteTasksQuery(uids: [1, 2]));"
          },
          {
            "lang": "Swift",
            "source": "client.deleteTasks(filter: DeleteTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/tasks/cancel": {
      "post": {
        "tags": [
          "Async task management"
        ],
        "summary": "Cancel tasks",
        "description": "Cancel enqueued and/or processing [tasks](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "cancel_tasks",
        "parameters": [
          {
            "name": "uids",
            "in": "query",
            "description": "Permits to filter tasks by their uid. By default, when the `uids` query\nparameter is not set, all task uids are returned. It's possible to\nspecify several uids by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "batchUids",
            "in": "query",
            "description": "Lets you filter tasks by their `batchUid`.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              231,
              423,
              598
            ]
          },
          {
            "name": "canceledBy",
            "in": "query",
            "description": "Permits to filter tasks using the uid of the task that canceled them.\nIt's possible to specify several task uids by separating them with\nthe `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "integer",
                "format": "u-int32",
                "minimum": 0
              }
            },
            "example": [
              374
            ]
          },
          {
            "name": "types",
            "in": "query",
            "description": "Permits to filter tasks by their related type. By default, when `types`\nquery parameter is not set, all task types are returned. It's possible\nto specify several types by separating them with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Kind"
              }
            },
            "example": [
              "documentDeletion"
            ]
          },
          {
            "name": "statuses",
            "in": "query",
            "description": "Permits to filter tasks by their status. By default, when `statuses`\nquery parameter is not set, all task statuses are returned. It's\npossible to specify several statuses by separating them with the `,`\ncharacter.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Status"
              }
            },
            "example": [
              "succeeded",
              "failed",
              "canceled"
            ]
          },
          {
            "name": "indexUids",
            "in": "query",
            "description": "Permits to filter tasks by their related index. By default, when\n`indexUids` query parameter is not set, the tasks of all the indexes\nare returned. It is possible to specify several indexes by separating\nthem with the `,` character.",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "example": [
              "movies",
              "theater"
            ]
          },
          {
            "name": "afterEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeEnqueuedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their enqueuedAt time. Matches tasks\nenqueued before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeStartedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their startedAt time. Matches tasks\nstarted before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "afterFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished after the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          },
          {
            "name": "beforeFinishedAt",
            "in": "query",
            "description": "Permits to filter tasks based on their finishedAt time. Matches tasks\nfinished before the given date. Supports RFC 3339 date format.",
            "required": false,
            "schema": {
              "type": "string"
            },
            "example": "2024-08-08T16:37:09.971Z"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully enqueued",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SummarizedTaskView"
                },
                "example": {
                  "taskUid": 147,
                  "indexUid": null,
                  "status": "enqueued",
                  "type": "taskCancelation",
                  "enqueuedAt": "2024-08-08T17:05:55.791772Z"
                }
              }
            }
          },
          "400": {
            "description": "A filter is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Query parameters to filter the tasks to cancel are missing. Available query parameters are: `uids`, `indexUids`, `statuses`, `types`, `canceledBy`, `beforeEnqueuedAt`, `afterEnqueuedAt`, `beforeStartedAt`, `afterStartedAt`, `beforeFinishedAt`, `afterFinishedAt`.",
                  "code": "missing_task_filters",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors#missing_task_filters"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.cancel",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/tasks/cancel?uids=1,2'"
          },
          {
            "lang": "JS",
            "source": "client.tasks.cancelTasks({ uids: [1, 2] })"
          },
          {
            "lang": "PHP",
            "source": "$client->cancelTasks((new CancelTasksQuery())->setUids([1, 2]));"
          },
          {
            "lang": "Python",
            "source": "client.cancel_tasks({'uids': ['1', '2']})"
          },
          {
            "lang": "Java",
            "source": "CancelTasksQuery query = new CancelTasksQuery().setUids(new int[] {1, 2})\nclient.cancelTasks(query);"
          },
          {
            "lang": "Ruby",
            "source": "client.cancel_tasks(uids: [1, 2])"
          },
          {
            "lang": "Go",
            "source": "client.CancelTasks(&meilisearch.CancelTasksQuery{\n  UIDS: []int64{1, 2},\n});"
          },
          {
            "lang": "C#",
            "source": "await client.CancelTasksAsync(new CancelTasksQuery { Uids = new List<int> { 1, 2 } });"
          },
          {
            "lang": "Rust",
            "source": "let mut query = tasks::TasksCancelQuery::new(&client);\nquery.with_uids([1, 2]);\n\nlet res = client.cancel_task_with(&query).await.unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.cancelTasks(params: CancelTasksQuery(uids: [1, 2]));\nap_indexes_1: \"await client.swapIndexes([\\n  SwapIndex(['indexA', 'indexB']),\\n  SwapIndex(['indexX', 'indexY']),\\n]);\"\narch_parameter_guide_hitsperpage_1: \"await client\\n    .index('movies')\\n    .search('', SearchQuery(hitsPerPage: 15))\\n    .asPaginatedResult();\"\narch_parameter_guide_page_1: \"await client\\n    .index('movies')\\n    .search('', SearchQuery(page: 2))\\n    .asPaginatedResult();\"\nnonyms_guide_1: \"await client.index('movies').updateSynonyms({\\n  'great': ['fantastic'],\\n  'fantastic': ['great'],\\n});\"\nte_guide_index_1: \"\\/\\/import 'dart:io';\\n\\/\\/import 'dart:convert';\\nfinal json = await File('games.json').readAsString();\\nawait client.index('games').addDocumentsJson(json);\"\nte_guide_filterable_attributes_1: \"await client\\n    .index('games')\\n    .updateFilterableAttributes(['release_timestamp']);\"\nte_guide_filter_1: \"await client.index('games').search(\\n      '',\\n      SearchQuery(\\n        filterExpression: Meili.and([\\n          Meili.gte(\\n            'release_timestamp'.toMeiliAttribute(),\\n            Meili.value(DateTime(2017, 12, 31, 23, 0)),\\n          ),\\n          Meili.lt(\\n            'release_timestamp'.toMeiliAttribute(),\\n            Meili.value(DateTime(2022, 12, 31, 23, 0)),\\n          ),\\n        ]),\\n      ),\\n    );\"\nte_guide_sortable_attributes_1: \"await client\\n    .index('games')\\n    .updateSortableAttributes(['release_timestamp']);\"\nte_guide_sort_1: \"await client\\n    .index('games')\\n    .search('', SearchQuery(sort: ['release_timestamp:desc']));\""
          },
          {
            "lang": "Swift",
            "source": "client.cancelTasks(filter: CancelTasksQuery(uids: [1, 2])) { (result) in\n    switch result {\n    case .success(let taskInfo):\n        print(taskInfo)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/tasks/{taskUid}": {
      "get": {
        "tags": [
          "Async task management"
        ],
        "summary": "Get task",
        "description": "Get a [task](https://www.meilisearch.com/docs/learn/async/asynchronous_operations)",
        "operationId": "get_task",
        "parameters": [
          {
            "name": "taskUid",
            "in": "path",
            "description": "The task identifier",
            "required": true,
            "schema": {
              "type": "string",
              "format": "u-int32"
            },
            "example": "0"
          }
        ],
        "responses": {
          "200": {
            "description": "Task successfully retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskView"
                },
                "example": {
                  "uid": 1,
                  "indexUid": "movies",
                  "status": "succeeded",
                  "type": "indexCreation",
                  "canceledBy": null,
                  "details": null,
                  "error": null,
                  "duration": "PT1S",
                  "enqueuedAt": "2021-01-01T09:39:00.000000Z",
                  "startedAt": "2021-01-01T09:39:01.000000Z",
                  "finishedAt": "2021-01-01T09:39:02.000000Z"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          },
          "404": {
            "description": "The task uid does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "Task :taskUid not found.",
                  "code": "task_not_found",
                  "type": "invalid_request",
                  "link": "https://docs.meilisearch.com/errors/#task_not_found"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "tasks.get",
              "tasks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/tasks/1'"
          },
          {
            "lang": "JS",
            "source": "client.tasks.getTask(1)"
          },
          {
            "lang": "PHP",
            "source": "$client->getTask(1);"
          },
          {
            "lang": "Python",
            "source": "client.get_task(1)"
          },
          {
            "lang": "Java",
            "source": "client.getTask(1);"
          },
          {
            "lang": "Ruby",
            "source": "client.task(1)"
          },
          {
            "lang": "Go",
            "source": "client.GetTask(1);"
          },
          {
            "lang": "Rust",
            "source": "let task: Task = client\n  .get_task(1)\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getTask(1);"
          },
          {
            "lang": "Swift",
            "source": "client.getTask(taskUid: 1) { (result) in\n      switch result {\n      case .success(let task):\n          print(task)\n      case .failure(let error):\n          print(error)\n      }\n  }"
          }
        ]
      }
    },
    "/version": {
      "get": {
        "tags": [
          "Version"
        ],
        "summary": "Get version",
        "description": "Current version of Meilisearch.",
        "operationId": "get_version",
        "responses": {
          "200": {
            "description": "Instance is healthy",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VersionResponse"
                },
                "example": {
                  "commitSha": "b46889b5f0f2f8b91438a08a358ba8f05fc09fc1",
                  "commitDate": "2021-07-08",
                  "pkgVersion": "0.23.0"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "version",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/version'"
          },
          {
            "lang": "JS",
            "source": "client.getVersion()"
          },
          {
            "lang": "PHP",
            "source": "$client->version();"
          },
          {
            "lang": "Python",
            "source": "client.get_version()"
          },
          {
            "lang": "Java",
            "source": "client.getVersion();"
          },
          {
            "lang": "Ruby",
            "source": "client.version"
          },
          {
            "lang": "Go",
            "source": "client.GetVersion()"
          },
          {
            "lang": "C#",
            "source": "await client.GetVersionAsync();"
          },
          {
            "lang": "Rust",
            "source": "let version: Version = client\n  .get_version()\n  .await\n  .unwrap();"
          },
          {
            "lang": "Dart",
            "source": "await client.getVersion();"
          },
          {
            "lang": "Swift",
            "source": "client.version { (result) in\n    switch result {\n    case .success(let version):\n        print(version)\n    case .failure(let error):\n        print(error)\n    }\n}"
          }
        ]
      }
    },
    "/webhooks": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "List webhooks",
        "description": "Get the list of all registered webhooks.",
        "operationId": "get_webhooks",
        "responses": {
          "200": {
            "description": "Webhooks are returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookResults"
                },
                "example": {
                  "results": [
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440000",
                      "url": "https://your.site/on-tasks-completed",
                      "headers": {
                        "Authorization": "Bearer a-secret-token"
                      },
                      "isEditable": true
                    },
                    {
                      "uuid": "550e8400-e29b-41d4-a716-446655440001",
                      "url": "https://another.site/on-tasks-completed",
                      "isEditable": true
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "example": {
                  "message": "The Authorization header is missing. It must use the bearer authorization method.",
                  "code": "missing_authorization_header",
                  "type": "auth",
                  "link": "https://docs.meilisearch.com/errors#missing_authorization_header"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/webhooks'"
          },
          {
            "lang": "JS",
            "source": "client.getWebhooks()"
          },
          {
            "lang": "Python",
            "source": "client.get_webhooks()"
          },
          {
            "lang": "Go",
            "source": "client.ListWebhooks();"
          },
          {
            "lang": "Rust",
            "source": "let webhooks = client.get_webhooks().await.unwrap();"
          }
        ]
      },
      "post": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Create webhook",
        "description": "Create a new webhook to receive task notifications.",
        "operationId": "post_webhook",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Webhook created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.create",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X POST 'MEILISEARCH_URL/webhooks' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"url\": \"WEBHOOK_TARGET_URL\",\n    \"headers\": {\n      \"authorization\": \"SECURITY_KEY\",\n      \"referer\": \"https://example.com\"\n    }\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.createWebhook({\n  url: 'WEBHOOK_TARGET_URL',\n  headers: {\n    authorization: 'SECURITY_KEY',\n    referer: 'https://example.com'\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.create_webhook({\n  'url': 'https://example.com/webhook',\n  'headers': {\"Authorization\":\"\", \"X-Custom-Header\":\"test\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client.AddWebhook(&meilisearch.AddWebhookRequest{\n  URL: \"WEBHOOK_TARGET_URL\",\n  Headers: map[string]string{\n    \"authorization\": \"SECURITY_KEY\",\n    \"referer\": \"https://example.com\"\n  },\n});"
          },
          {
            "lang": "Rust",
            "source": "let mut payload = meilisearch_sdk::webhooks::WebhookCreate::new(\"WEBHOOK_TARGET_URL\");\npayload\n  .insert_header(\"authorization\", \"SECURITY_KEY\")\n  .insert_header(\"referer\", \"https://example.com\");\nlet webhook = client.create_webhook(&payload).await.unwrap();"
          }
        ]
      }
    },
    "/webhooks/{uuid}": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Get webhook",
        "description": "Get a single webhook by its UUID.",
        "operationId": "get_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Webhook found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.get",
              "webhooks.*",
              "*.get",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X GET 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID'"
          },
          {
            "lang": "JS",
            "source": "client.getWebhook(WEBHOOK_UUID)"
          },
          {
            "lang": "Python",
            "source": "client.get_webhook('WEBHOOK_UID')"
          },
          {
            "lang": "Go",
            "source": "client.GetWebhook(\"WEBHOOK_UUID\");"
          },
          {
            "lang": "Rust",
            "source": "let webhook = client.get_webhook(\"WEBHOOK_UUID\").await.unwrap();"
          }
        ]
      },
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Delete webhook",
        "description": "Delete an existing webhook by its UUID.",
        "operationId": "delete_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Webhook deleted successfully"
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "404": {
            "description": "Webhook not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.delete",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X DELETE 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID'"
          },
          {
            "lang": "JS",
            "source": "client.deleteWebhook(WEBHOOK_UUID)"
          },
          {
            "lang": "Python",
            "source": "client.delete_webhook('WEBHOOK_UID')"
          },
          {
            "lang": "Go",
            "source": "client.DeleteWebhook(\"WEBHOOK_UUID\");"
          },
          {
            "lang": "Rust",
            "source": "client.delete_webhook(\"WEBHOOK_UUID\").await.unwrap();"
          }
        ]
      },
      "patch": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Update webhook",
        "description": "Update an existing webhook's URL or headers.",
        "operationId": "patch_webhook",
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "description": "The universally unique identifier of the webhook",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WebhookSettings"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Webhook updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
                },
                "example": {
                  "uuid": "550e8400-e29b-41d4-a716-446655440000",
                  "url": "https://your.site/on-tasks-completed",
                  "headers": {
                    "Authorization": "Bearer a-secret-token"
                  },
                  "isEditable": true
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          },
          "401": {
            "description": "The authorization header is missing",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        },
        "security": [
          {
            "Bearer": [
              "webhooks.update",
              "webhooks.*",
              "*"
            ]
          }
        ],
        "x-codeSamples": [
          {
            "lang": "cURL",
            "source": "curl \\\n  -X PATCH 'MEILISEARCH_URL/webhooks/WEBHOOK_UUID' \\\n  -H 'Content-Type: application/json' \\\n  --data-binary '{\n    \"header\": {\n      \"referer\": null\n    }\n  }'"
          },
          {
            "lang": "JS",
            "source": "client.updateWebhook(WEBHOOK_UUID, {\n  headers: {\n    referer: null\n  }\n})"
          },
          {
            "lang": "Python",
            "source": "client.update_webhook('WEBHOOK_UID', {\n  'url': 'https://example.com/new-webhook',\n  'headers': {\"Authorization\":\"\", \"X-Custom-Header\":\"test\"},\n})"
          },
          {
            "lang": "Go",
            "source": "client.UpdateWebhook(\"WEBHOOK_UUID\", &meilisearch.UpdateWebhookRequest{\n  Header: map[string]string{\n    \"referer\": \"\"\n  },\n});"
          },
          {
            "lang": "Rust",
            "source": "let mut update = meilisearch_sdk::webhooks::WebhookUpdate::new();\nupdate.remove_header(\"referer\");\nlet webhook = client\n  .update_webhook(\"WEBHOOK_UUID\", &update)\n  .await\n  .unwrap();"
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "Action": {
        "type": "string",
        "enum": [
          "*",
          "search",
          "documents.*",
          "documents.add",
          "documents.get",
          "documents.delete",
          "indexes.*",
          "indexes.create",
          "indexes.get",
          "indexes.update",
          "indexes.delete",
          "indexes.swap",
          "tasks.*",
          "tasks.cancel",
          "tasks.delete",
          "tasks.get",
          "settings.*",
          "settings.get",
          "settings.update",
          "stats.*",
          "stats.get",
          "metrics.*",
          "metrics.get",
          "dumps.*",
          "dumps.create",
          "snapshots.*",
          "snapshots.create",
          "version",
          "keys.create",
          "keys.get",
          "keys.update",
          "keys.delete",
          "experimental.get",
          "experimental.update",
          "export",
          "network.get",
          "network.update",
          "chatCompletions",
          "chats.*",
          "chats.get",
          "chats.delete",
          "chatsSettings.*",
          "chatsSettings.get",
          "chatsSettings.update",
          "*.get",
          "webhooks.get",
          "webhooks.update",
          "webhooks.delete",
          "webhooks.create",
          "webhooks.*",
          "indexes.compact",
          "fields.post"
        ]
      },
      "AllBatches": {
        "type": "object",
        "description": "Response containing a paginated list of batches",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchView"
            },
            "description": "Array of batch objects"
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "description": "Total number of batches",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "description": "Maximum number of batches returned",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The first batch uid returned",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "Value to send in from to fetch the next slice of results",
            "minimum": 0
          }
        }
      },
      "AllTasks": {
        "type": "object",
        "description": "Response containing a paginated list of tasks",
        "required": [
          "results",
          "total",
          "limit"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskView"
            },
            "description": "Array of task objects matching the query"
          },
          "total": {
            "type": "integer",
            "format": "u-int64",
            "description": "Total number of tasks matching the query",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "format": "u-int32",
            "description": "Maximum number of tasks returned",
            "minimum": 0
          },
          "from": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The first task uid returned",
            "minimum": 0
          },
          "next": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "Value to send in from to fetch the next slice of results. Null when all data has been browsed",
            "minimum": 0
          }
        }
      },
      "AttributePatterns": {
        "type": "object",
        "description": "A collection of patterns used to match attribute names. Patterns can\ninclude wildcards (`*`) for flexible matching. For example, `title`\nmatches exactly, `overview_*` matches any attribute starting with\n`overview_`, and `*_date` matches any attribute ending with `_date`.",
        "required": [
          "patterns"
        ],
        "properties": {
          "patterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "An array of attribute name patterns. Each pattern can be an exact\nattribute name, or include wildcards (`*`) at the start, end, or\nboth. Examples: `[\"title\", \"description_*\", \"*_date\", \"*content*\"]`.",
            "example": [
              "title",
              "overview_*",
              "release_date"
            ]
          }
        }
      },
      "BatchStats": {
        "type": "object",
        "description": "Statistics for a batch of tasks",
        "required": [
          "totalNbTasks",
          "status",
          "types",
          "indexUids"
        ],
        "properties": {
          "totalNbTasks": {
            "$ref": "#/components/schemas/u32",
            "description": "Total number of tasks in the batch"
          },
          "status": {
            "type": "object",
            "description": "Count of tasks by status",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The status of a task.",
              "enum": [
                "enqueued",
                "processing",
                "succeeded",
                "failed",
                "canceled"
              ],
              "example": "processing"
            }
          },
          "types": {
            "type": "object",
            "description": "Count of tasks by type",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string",
              "description": "The type of the task.",
              "enum": [
                "documentAdditionOrUpdate",
                "documentEdition",
                "documentDeletion",
                "settingsUpdate",
                "indexCreation",
                "indexDeletion",
                "indexUpdate",
                "indexSwap",
                "taskCancelation",
                "taskDeletion",
                "dumpCreation",
                "snapshotCreation",
                "export",
                "upgradeDatabase",
                "indexCompaction",
                "networkTopologyChange"
              ],
              "example": "documentAdditionOrUpdate"
            }
          },
          "indexUids": {
            "type": "object",
            "description": "Count of tasks by index UID",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int32",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "progressTrace": {
            "type": "object",
            "description": "Detailed progress trace information",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "writeChannelCongestion": {
            "type": [
              "object",
              "null"
            ],
            "description": "Write channel congestion metrics",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "internalDatabaseSizes": {
            "type": "object",
            "description": "Internal database size information",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "BatchStatsView": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BatchStats",
            "description": "Core batch statistics including the total number of tasks, counts by\nstatus (succeeded, failed, canceled), task types included, and which\nindexes were affected by this batch."
          },
          {
            "type": "object",
            "properties": {
              "embedderRequests": {
                "$ref": "#/components/schemas/EmbedderStatsView",
                "description": "Statistics about AI embedder API requests made during batch processing.\nIncludes total requests, successful/failed counts, and response times.\nOnly present when the batch involved vector embedding operations."
              }
            }
          }
        ],
        "description": "Provides comprehensive statistics about a batch's execution.\n\nIncludes task counts, status breakdowns, and AI embedder usage. This\ninformation is useful for monitoring system performance and understanding\nbatch composition."
      },
      "BatchView": {
        "type": "object",
        "description": "Represents a batch of tasks that were processed together.\n\nMeilisearch groups compatible tasks into batches for efficient processing.\nFor example, multiple document additions to the same index may be batched\ntogether. Use this view to monitor batch progress and performance.",
        "required": [
          "uid",
          "details",
          "stats"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/u32",
            "description": "The unique sequential identifier assigned to this batch. Batch UIDs\nare assigned in order of creation and can be used to retrieve specific\nbatch information or correlate tasks that were processed together."
          },
          "progress": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ProgressView",
                "description": "Real-time progress information for the batch if it's currently being\nprocessed. Contains details about which step is executing and the\npercentage of completion. This is `null` for completed batches."
              }
            ]
          },
          "details": {
            "type": "object",
            "description": "Aggregated details from all tasks in this batch. For example, if the\nbatch contains multiple document addition tasks, this will show the\ntotal number of documents received and indexed across all tasks."
          },
          "stats": {
            "$ref": "#/components/schemas/BatchStatsView",
            "description": "Statistical information about the batch, including the number of tasks\nby status, the types of tasks included, and the indexes affected.\nUseful for understanding the composition and outcome of the batch."
          },
          "duration": {
            "type": [
              "string",
              "null"
            ],
            "description": "The total time spent processing this batch, formatted as an ISO-8601\nduration (e.g., `PT2.5S` for 2.5 seconds). This is `null` for batches\nthat haven't finished processing yet."
          },
          "startedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when Meilisearch began processing this batch, formatted\nas an RFC 3339 date-time string. All batches have a start time as it's\nset when processing begins."
          },
          "finishedAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The timestamp when this batch finished processing, formatted as an\nRFC 3339 date-time string. This is `null` for batches that are still\nbeing processed."
          },
          "batchStrategy": {
            "type": "string",
            "description": "Explains why the batch was finalized and stopped accepting more tasks.\nCommon reasons include reaching the maximum batch size, encountering\nincompatible tasks, or processing being explicitly triggered."
          }
        }
      },
      "BrowseQuery": {
        "type": "object",
        "description": "Request body for browsing and retrieving documents from an index. Use\nthis to fetch documents with optional filtering, sorting, and pagination.\nThis is useful for displaying document lists, exporting data, or\ninspecting index contents.",
        "required": [
          "offset",
          "limit",
          "retrieveVectors"
        ],
        "properties": {
          "offset": {
            "type": "integer",
            "description": "Number of documents to skip in the response. Use together with `limit`\nfor pagination through large document sets. For example, to get\ndocuments 151-170, set `offset=150` and `limit=20`. Defaults to `0`.",
            "example": 150,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of documents to return in a single response. Use\ntogether with `offset` for pagination. Higher values return more\nresults but may increase response time and memory usage. Defaults to\n`20`.",
            "default": 20,
            "example": 1,
            "minimum": 0
          },
          "fields": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Array of document attributes to include in the response. If not\nspecified, all attributes listed in the `displayedAttributes` setting\nare returned. Use this to reduce response size by only requesting the\nfields you need. Example: `[\"title\", \"description\", \"price\"]`.",
            "example": [
              "title, description"
            ]
          },
          "retrieveVectors": {
            "type": "boolean",
            "description": "When `true`, includes the vector embeddings in the response for\ndocuments that have them. This is useful when you need to inspect or\nexport vector data. Note that this can significantly increase response\nsize. Defaults to `false`.",
            "example": true
          },
          "ids": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Array of specific document IDs to retrieve. Only documents with\nmatching primary key values will be returned. If not specified, all\ndocuments matching other criteria are returned. This is useful for\nfetching specific known documents.",
            "example": [
              "cody",
              "finn",
              "brandy",
              "gambit"
            ]
          },
          "filter": {
            "description": "Filter expression to select which documents to return. Uses the same\nsyntax as search filters. Only documents matching the filter will be\nincluded in the response. Example: `\"genres = action AND rating > 4\"`\nor as an array `[[\"genres = action\"], \"rating > 4\"]`."
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Array of attributes to sort the documents by. Each entry should be in\nthe format `attribute:direction` where direction is either `asc`\n(ascending) or `desc` (descending). Example: `[\"price:asc\",\n\"rating:desc\"]` sorts by price ascending, then by rating descending.",
            "example": [
              "title:asc",
              "rating:desc"
            ]
          }
        }
      },
      "ChatSearchParams": {
        "type": "object",
        "description": "Search parameters that control how the LLM queries this index.\n\nThese settings are applied automatically when the chat system\nperforms searches.",
        "properties": {
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery",
                "description": "Configuration for hybrid search combining keyword and semantic search.\nSet the `semanticRatio` to balance between keyword matching (0.0) and\nsemantic similarity (1.0). Requires an embedder to be configured."
              }
            ]
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of documents to return when the LLM queries this index.\nHigher values provide more context to the LLM but may increase\nresponse time and token usage.",
            "minimum": 0
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Sort criteria for ordering search results before presenting to the LLM.\nEach entry should be in the format `attribute:asc` or `attribute:desc`.\nExample: `[\"price:asc\", \"rating:desc\"]`."
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ],
            "description": "The attribute used for deduplicating results. When set, only one\ndocument per unique value of this attribute is returned. Useful for\navoiding duplicate content in LLM responses."
          },
          "matchingStrategy": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MatchingStrategy",
                "description": "Strategy for matching query terms. `last` (default) matches all words\nand returns documents matching at least the last word. `all` requires\nall words to match. `frequency` prioritizes less frequent words."
              }
            ]
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Restricts the search to only the specified attributes. If not set, all\nsearchable attributes are searched.\nExample: `[\"title\", \"description\"]` searches only these two fields."
          },
          "rankingScoreThreshold": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/RankingScoreThreshold",
                "description": "Minimum ranking score (0.0 to 1.0) that documents must achieve to be\nincluded in results. Documents below this threshold are excluded.\nUseful for filtering out low-relevance results."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "ChatSettings": {
        "type": "object",
        "description": "Configuration settings for AI-powered chat and search functionality.\n\nThese settings control how documents are presented to the LLM and what\nsearch parameters are used when the LLM queries the index.",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A description of this index that helps the LLM understand its contents\nand purpose. This description is provided to the LLM to help it decide\nwhen and how to query this index.\nExample: \"Contains product catalog with prices and descriptions\"."
          },
          "documentTemplate": {
            "type": [
              "string",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum size in bytes for the rendered document text. Texts longer than\nthis limit are truncated. This prevents very large documents from\nconsuming too much context in the LLM conversation.\nDefaults to `400` bytes.",
            "minimum": 0
          },
          "searchParameters": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSearchParams",
                "description": "Default search parameters used when the LLM queries this index.\nThese settings control how search results are retrieved and ranked.\nIf not specified, standard search defaults are used."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Code": {
        "type": "string",
        "enum": [
          "api_key_already_exists",
          "api_key_not_found",
          "bad_parameter",
          "bad_request",
          "database_size_limit_reached",
          "document_not_found",
          "dump_already_processing",
          "dump_not_found",
          "dump_process_failed",
          "duplicate_index_found",
          "immutable_api_key_actions",
          "immutable_api_key_created_at",
          "immutable_api_key_expires_at",
          "immutable_api_key_indexes",
          "immutable_api_key_key",
          "immutable_api_key_uid",
          "immutable_api_key_updated_at",
          "immutable_index_created_at",
          "immutable_index_updated_at",
          "import_task_already_received",
          "import_task_unknown_remote",
          "import_task_without_network_task",
          "index_already_exists",
          "index_creation_failed",
          "index_not_found",
          "index_primary_key_already_exists",
          "index_primary_key_multiple_candidates_found",
          "index_primary_key_no_candidate_found",
          "internal",
          "invalid_api_key",
          "invalid_api_key_actions",
          "invalid_api_key_description",
          "invalid_api_key_expires_at",
          "invalid_api_key_indexes",
          "invalid_api_key_limit",
          "invalid_api_key_name",
          "invalid_api_key_offset",
          "invalid_api_key_uid",
          "invalid_content_type",
          "invalid_document_csv_delimiter",
          "invalid_document_fields",
          "invalid_document_retrieve_vectors",
          "missing_document_filter",
          "missing_document_edition_function",
          "inconsistent_document_change_headers",
          "invalid_document_filter",
          "invalid_document_sort",
          "invalid_document_geo_field",
          "invalid_document_geojson_field",
          "invalid_header_value",
          "invalid_vector_dimensions",
          "invalid_vectors_type",
          "invalid_document_id",
          "invalid_document_ids",
          "invalid_document_limit",
          "invalid_document_offset",
          "invalid_search_embedder",
          "invalid_similar_embedder",
          "invalid_search_hybrid_query",
          "invalid_index_limit",
          "invalid_index_offset",
          "invalid_index_primary_key",
          "invalid_index_custom_metadata",
          "invalid_skip_creation",
          "invalid_index_uid",
          "invalid_multi_search_facets",
          "invalid_multi_search_facets_by_index",
          "invalid_multi_search_facet_order",
          "invalid_multi_search_query_personalization",
          "invalid_multi_search_query_show_performance_details",
          "invalid_multi_search_federated",
          "invalid_multi_search_federation_options",
          "invalid_multi_search_max_values_per_facet",
          "invalid_multi_search_merge_facets",
          "invalid_multi_search_query_facets",
          "invalid_multi_search_query_pagination",
          "invalid_multi_search_query_ranking_rules",
          "invalid_multi_search_query_position",
          "invalid_multi_search_remote",
          "invalid_multi_search_weight",
          "invalid_network_leader",
          "invalid_network_remotes",
          "invalid_network_self",
          "invalid_network_search_api_key",
          "invalid_network_write_api_key",
          "invalid_network_url",
          "invalid_search_attributes_to_search_on",
          "invalid_search_attributes_to_crop",
          "invalid_search_attributes_to_highlight",
          "invalid_similar_attributes_to_retrieve",
          "invalid_similar_retrieve_vectors",
          "invalid_search_attributes_to_retrieve",
          "invalid_search_ranking_score_threshold",
          "invalid_similar_ranking_score_threshold",
          "invalid_search_retrieve_vectors",
          "invalid_search_crop_length",
          "invalid_search_crop_marker",
          "invalid_search_facets",
          "invalid_search_semantic_ratio",
          "invalid_search_locales",
          "invalid_facet_search_exhaustive_facet_count",
          "invalid_facet_search_facet_name",
          "invalid_similar_id",
          "invalid_search_filter",
          "invalid_similar_filter",
          "invalid_search_highlight_post_tag",
          "invalid_search_highlight_pre_tag",
          "invalid_search_hits_per_page",
          "invalid_similar_limit",
          "invalid_search_limit",
          "invalid_search_matching_strategy",
          "invalid_similar_offset",
          "invalid_search_offset",
          "invalid_search_page",
          "invalid_search_q",
          "invalid_facet_search_query",
          "invalid_facet_search_name",
          "facet_search_disabled",
          "invalid_search_vector",
          "invalid_search_media",
          "invalid_search_show_matches_position",
          "invalid_search_show_ranking_score",
          "invalid_similar_show_ranking_score",
          "invalid_search_show_ranking_score_details",
          "invalid_search_show_performance_details",
          "invalid_search_use_network",
          "invalid_similar_show_ranking_score_details",
          "invalid_similar_show_performance_details",
          "invalid_search_sort",
          "invalid_search_distinct",
          "invalid_search_personalize",
          "invalid_search_personalize_user_context",
          "invalid_search_media_and_vector",
          "invalid_settings_displayed_attributes",
          "invalid_settings_distinct_attribute",
          "invalid_settings_proximity_precision",
          "invalid_settings_facet_search",
          "invalid_settings_prefix_search",
          "invalid_settings_faceting",
          "invalid_settings_filterable_attributes",
          "invalid_settings_pagination",
          "invalid_settings_search_cutoff_ms",
          "invalid_settings_embedders",
          "invalid_settings_ranking_rules",
          "invalid_settings_searchable_attributes",
          "invalid_settings_sortable_attributes",
          "invalid_settings_stop_words",
          "invalid_settings_non_separator_tokens",
          "invalid_settings_separator_tokens",
          "invalid_settings_dictionary",
          "invalid_settings_synonyms",
          "invalid_settings_typo_tolerance",
          "invalid_settings_localized_attributes",
          "invalid_state",
          "invalid_store_file",
          "invalid_swap_duplicate_index_found",
          "invalid_swap_indexes",
          "invalid_swap_rename",
          "invalid_task_after_enqueued_at",
          "invalid_task_after_finished_at",
          "invalid_task_after_started_at",
          "invalid_task_before_enqueued_at",
          "invalid_task_before_finished_at",
          "invalid_task_before_started_at",
          "invalid_task_canceled_by",
          "invalid_task_from",
          "invalid_task_limit",
          "invalid_task_reverse",
          "invalid_task_statuses",
          "invalid_task_types",
          "invalid_task_uids",
          "invalid_batch_uids",
          "io_error",
          "feature_not_enabled",
          "malformed_payload",
          "max_fields_limit_exceeded",
          "missing_api_key_actions",
          "missing_api_key_expires_at",
          "missing_api_key_indexes",
          "missing_authorization_header",
          "missing_content_type",
          "missing_document_id",
          "missing_facet_search_facet_name",
          "missing_index_uid",
          "missing_master_key",
          "missing_network_url",
          "missing_payload",
          "missing_search_hybrid",
          "missing_swap_indexes",
          "missing_task_filters",
          "network_version_mismatch",
          "no_space_left_on_device",
          "not_leader",
          "payload_too_large",
          "remote_bad_response",
          "remote_bad_request",
          "remote_could_not_send_request",
          "remote_invalid_api_key",
          "remote_remote_error",
          "remote_timeout",
          "too_many_search_requests",
          "task_not_found",
          "task_file_not_found",
          "batch_not_found",
          "too_many_open_files",
          "too_many_vectors",
          "unexpected_network_previous_remotes",
          "network_version_too_old",
          "unprocessed_network_task",
          "unretrievable_document",
          "unretrievable_error_code",
          "unsupported_media_type",
          "invalid_s3_snapshot_request",
          "invalid_s3_snapshot_parameters",
          "s3_snapshot_server_error",
          "vector_embedding_error",
          "not_found_similar_id",
          "invalid_document_edition_context",
          "invalid_document_edition_function_filter",
          "edit_documents_by_function_error",
          "invalid_settings_index_chat",
          "invalid_settings_vector_store",
          "invalid_export_url",
          "invalid_export_api_key",
          "invalid_export_payload_size",
          "invalid_export_indexes_patterns",
          "invalid_export_index_filter",
          "invalid_export_index_override_settings",
          "unimplemented_external_function_calling",
          "unimplemented_non_streaming_chat_completions",
          "unimplemented_multi_choice_chat_completions",
          "chat_not_found",
          "invalid_chat_setting_document_template",
          "invalid_chat_completion_org_id",
          "invalid_chat_completion_project_id",
          "invalid_chat_completion_api_version",
          "invalid_chat_completion_deployment_id",
          "invalid_chat_completion_source",
          "invalid_chat_completion_base_api",
          "invalid_chat_completion_api_key",
          "invalid_chat_completion_prompts",
          "invalid_chat_completion_system_prompt",
          "invalid_chat_completion_search_description_prompt",
          "invalid_chat_completion_search_query_param_prompt",
          "invalid_chat_completion_search_filter_param_prompt",
          "invalid_chat_completion_search_index_uid_param_prompt",
          "invalid_chat_completion_pre_query_prompt",
          "invalid_index_fields_filter",
          "invalid_index_fields_filter_attribute_patterns",
          "invalid_index_fields_filter_displayed",
          "invalid_index_fields_filter_searchable",
          "invalid_index_fields_filter_sortable",
          "invalid_index_fields_filter_distinct",
          "invalid_index_fields_filter_ranking_rule",
          "invalid_index_fields_filter_filterable",
          "requires_enterprise_edition",
          "invalid_webhooks",
          "invalid_webhook_url",
          "invalid_webhook_headers",
          "immutable_webhook",
          "invalid_webhook_uuid",
          "webhook_not_found",
          "immutable_webhook_uuid",
          "immutable_webhook_is_editable"
        ]
      },
      "ComputedFacets": {
        "type": "object",
        "description": "Computed facet data from a search",
        "required": [
          "distribution",
          "stats"
        ],
        "properties": {
          "distribution": {
            "type": "object",
            "description": "Count of documents for each facet value",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "integer",
                "format": "u-int64",
                "minimum": 0
              },
              "propertyNames": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "stats": {
            "type": "object",
            "description": "Numeric statistics for each facet",
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "CreateApiKey": {
        "type": "object",
        "required": [
          "actions",
          "indexes"
        ],
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A description for the key. `null` if empty.",
            "example": null
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "A human-readable name for the key. `null` if empty.",
            "example": "Indexing Products API key"
          },
          "uid": {
            "type": [
              "string",
              "null"
            ],
            "description": "A uuid v4 to identify the API Key. If not specified, it's generated by Meilisearch.",
            "example": "01b4bc42-eb33-4041-b481-254d00cce834"
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "A list of actions permitted for the key. `[\"*\"]` for all actions. The\n`*` character can be used as a wildcard when located at the last\nposition. e.g. `documents.*` to authorize access on all documents\nendpoints.",
            "example": [
              "documents.add"
            ]
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of accessible indexes permitted for the key. `[\"*\"]` for all\nindexes. The `*` character can be used as a wildcard when located at\nthe last position. e.g. `products_*` to allow access to all indexes\nwhose names start with `products_`.",
            "example": [
              "products"
            ]
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "Represent the expiration date and time as RFC 3339 format. `null`\nequals to no expiration time."
          }
        }
      },
      "DbTaskNetwork": {
        "oneOf": [
          {
            "type": "object",
            "description": "Tasks that were duplicated from `origin`",
            "required": [
              "origin"
            ],
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/Origin"
              }
            }
          },
          {
            "type": "object",
            "description": "Tasks that were duplicated as `remote_tasks`",
            "required": [
              "remote_tasks"
            ],
            "properties": {
              "remote_tasks": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/RemoteTask"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "network_version": {
                "type": "string",
                "format": "uuid"
              }
            }
          },
          {
            "type": "object",
            "description": "Document import tasks sent in the context of `network_change`",
            "required": [
              "import_from",
              "network_change"
            ],
            "properties": {
              "import_from": {
                "$ref": "#/components/schemas/ImportData"
              },
              "network_change": {
                "$ref": "#/components/schemas/Origin"
              }
            }
          }
        ]
      },
      "DetailsExportIndexSettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExportIndexSettings"
          },
          {
            "type": "object",
            "properties": {
              "matchedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "minimum": 0
              }
            }
          }
        ]
      },
      "DetailsView": {
        "allOf": [
          {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Settings_Unchecked",
                "description": "The complete settings object that was applied by a `settingsUpdate`\ntask. Only the settings that were modified are included in this\nobject."
              }
            ]
          },
          {
            "type": "object",
            "properties": {
              "receivedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of documents that were sent in the request payload for a\n`documentAdditionOrUpdate` task. This count is determined before any\nprocessing occurs.",
                "minimum": 0
              },
              "indexedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of documents that were successfully indexed after\nprocessing a `documentAdditionOrUpdate` task. This may differ from\n`receivedDocuments` if some documents were invalid or duplicates.\nThe inner `null` indicates the task is still processing.",
                "minimum": 0
              },
              "editedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of documents that were modified by an `documentEdition`\ntask using a RHAI function. The inner `null` indicates the task is\nstill processing.",
                "minimum": 0
              },
              "primaryKey": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The primary key attribute set for the index. For `indexCreation`\ntasks, this is the primary key that was specified. For `indexUpdate`\ntasks, this shows the new primary key if it was changed. The inner\n`null` means no primary key was specified and Meilisearch will infer\nit from documents."
              },
              "providedIds": {
                "type": [
                  "integer",
                  "null"
                ],
                "description": "The number of document IDs that were provided in a `documentDeletion`\nrequest. This is the count before processing - the actual number\ndeleted may be lower if some IDs didn't exist.",
                "minimum": 0
              },
              "deletedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of documents that were actually removed from the index for\n`documentDeletion`, `documentDeletionByFilter`, or `indexDeletion`\ntasks. The inner `null` indicates the task is still processing.",
                "minimum": 0
              },
              "matchedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of tasks that matched the filter criteria for a\n`taskCancelation` or `taskDeletion` request. This is determined when\nthe request is received, before any cancellation or deletion occurs.",
                "minimum": 0
              },
              "canceledTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of tasks that were successfully canceled by a\n`taskCancelation` task. This may be less than `matchedTasks` if some\ntasks completed before they could be canceled. The inner `null`\nindicates the task is still processing.",
                "minimum": 0
              },
              "deletedTasks": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of tasks that were successfully deleted by a `taskDeletion`\ntask. The inner `null` indicates the task is still processing.",
                "minimum": 0
              },
              "originalFilter": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The original filter query string that was used to select tasks for a\n`taskCancelation` or `taskDeletion` operation. Useful for\nunderstanding which tasks were targeted."
              },
              "dumpUid": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The unique identifier assigned to the dump file created by a\n`dumpCreation` task. Use this UID to locate the dump file in the\ndumps directory. The inner `null` indicates the task is still\nprocessing or failed before generating a UID."
              },
              "context": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "The context object that was provided to the RHAI function for a\n`documentEdition` task. This object contains data that the function\ncan access during document processing."
              },
              "function": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The RHAI function code that was executed for a `documentEdition`\ntask. This function is applied to each document matching the filter."
              },
              "swaps": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/IndexSwap"
                },
                "description": "The list of index swap operations that were performed by an\n`indexSwap` task. Each swap specifies two indexes that exchanged\ntheir contents."
              },
              "upgradeFrom": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The Meilisearch version before a database upgrade was performed.\nFormatted as `vX.Y.Z`."
              },
              "upgradeTo": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The Meilisearch version after a database upgrade was completed.\nFormatted as `vX.Y.Z`."
              },
              "url": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The destination URL where data is being exported for an `export`\ntask. This is the endpoint that receives the exported index data."
              },
              "apiKey": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The API key used for authentication when exporting data to a remote\nMeilisearch instance. This value is partially masked for security."
              },
              "payloadSize": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The maximum payload size configured for an `export` task, formatted\nas a human-readable string (e.g., `100 MB`). This limits the size of\neach batch of documents sent during export."
              },
              "indexes": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "A map of index patterns to their export settings for an `export`\ntask. The keys are index patterns (which may include wildcards) and\nthe values contain the specific export configuration for matching\nindexes.",
                "additionalProperties": {
                  "$ref": "#/components/schemas/DetailsExportIndexSettings"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "oldIndexUid": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The original unique identifier of the index before an `indexRename`\noperation. This is the name the index had before it was renamed."
              },
              "newIndexUid": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The new unique identifier assigned to the index after an `indexRename`\noperation. This is the name the index has after being renamed."
              },
              "preCompactionSize": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The size of the index before an `indexCompaction` task was performed,\nformatted as a human-readable string (e.g., `1.5 GB`). Compare with\n`postCompactionSize` to see how much space was reclaimed."
              },
              "postCompactionSize": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "The size of the index after an `indexCompaction` task completed,\nformatted as a human-readable string (e.g., `1.2 GB`). This should\nbe smaller than or equal to `preCompactionSize`."
              },
              "movedDocuments": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int64",
                "description": "The number of documents that were redistributed during a\n`networkTopologyChange` task in a distributed deployment. This\noccurs when the cluster configuration changes.",
                "minimum": 0
              },
              "message": {
                "type": [
                  "string",
                  "null"
                ],
                "description": "A human-readable message providing additional information about the\ntask, such as status updates or explanatory text about what occurred\nduring processing."
              }
            }
          }
        ],
        "description": "Contains type-specific details about a task's execution.\n\nThe fields present depend on the task type. For example, document addition\ntasks will have `receivedDocuments` and `indexedDocuments`, while settings\nupdate tasks will have the applied settings."
      },
      "DistributionShift": {
        "type": "object",
        "description": "Describes the mean and sigma of distribution of embedding similarity in the embedding space.\n\nThe intended use is to make the similarity score more comparable to the regular ranking score.\nThis allows to correct effects where results are too \"packed\" around a certain value.",
        "required": [
          "current_mean",
          "current_sigma"
        ],
        "properties": {
          "current_mean": {
            "type": "number",
            "format": "float",
            "description": "Value where the results are \"packed\".\n\nSimilarity scores are translated so that they are packed around 0.5 instead"
          },
          "current_sigma": {
            "type": "number",
            "format": "float",
            "description": "standard deviation of a similarity score.\n\nSet below 0.4 to make the results less packed around the mean, and above 0.4 to make them more packed."
          }
        }
      },
      "DocumentDeletionByFilter": {
        "type": "object",
        "description": "Request body for deleting documents by filter",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {
            "description": "Filter expression to match documents for deletion"
          }
        }
      },
      "DocumentEditionByFunction": {
        "type": "object",
        "description": "Request body for editing documents using a JavaScript function",
        "required": [
          "function"
        ],
        "properties": {
          "filter": {
            "description": "Filter expression to select which documents to edit"
          },
          "context": {
            "description": "Data to make available for the editing function"
          },
          "function": {
            "type": "string",
            "description": "RHAI function to apply to each document"
          }
        }
      },
      "EmbedderSource": {
        "type": "string",
        "enum": [
          "openAi",
          "huggingFace",
          "ollama",
          "userProvided",
          "rest",
          "composite"
        ]
      },
      "EmbedderStatsView": {
        "type": "object",
        "description": "Statistics for embedder requests",
        "required": [
          "total",
          "failed"
        ],
        "properties": {
          "total": {
            "type": "integer",
            "description": "Total number of embedder requests",
            "minimum": 0
          },
          "failed": {
            "type": "integer",
            "description": "Number of failed embedder requests",
            "minimum": 0
          },
          "lastError": {
            "type": [
              "string",
              "null"
            ],
            "description": "Last error message from the embedder"
          }
        }
      },
      "ErrorType": {
        "type": "string",
        "enum": [
          "internal",
          "invalid_request",
          "auth",
          "system"
        ]
      },
      "Export": {
        "type": "object",
        "description": "Request body for exporting data to a remote Meilisearch instance",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL of the destination Meilisearch instance",
            "example": "https://ms-1234.heaven.meilisearch.com"
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "API key for authenticating with the destination instance",
            "example": "1234abcd"
          },
          "payloadSize": {
            "type": [
              "string",
              "null"
            ],
            "description": "Maximum payload size per request",
            "example": "24MiB"
          },
          "indexes": {
            "type": [
              "object",
              "null"
            ],
            "description": "Index patterns to export with their settings",
            "additionalProperties": {
              "$ref": "#/components/schemas/ExportIndexSettings"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "*": {
                "filter": null
              }
            }
          }
        }
      },
      "ExportIndexSettings": {
        "type": "object",
        "description": "Export settings for a specific index",
        "properties": {
          "filter": {
            "type": [
              "string",
              "null"
            ],
            "description": "Filter expression to select which documents to export",
            "example": "genres = action"
          },
          "overrideSettings": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Whether to override settings on the destination index",
            "example": true
          }
        }
      },
      "FacetSearchQuery": {
        "type": "object",
        "description": "Request body for searching facet values",
        "required": [
          "facet_name",
          "matching_strategy"
        ],
        "properties": {
          "facet_query": {
            "type": [
              "string",
              "null"
            ],
            "description": "Query string to search for facet values"
          },
          "facet_name": {
            "type": "string",
            "description": "Name of the facet to search"
          },
          "q": {
            "type": [
              "string",
              "null"
            ],
            "description": "Query string to filter documents before facet search"
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            },
            "description": "Custom query vector for semantic search"
          },
          "media": {
            "description": "Multimodal content for AI-powered search"
          },
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery",
                "description": "Hybrid search configuration that combines keyword search with semantic\n(vector) search. Set `semanticRatio` to balance between keyword\nmatching (0.0) and semantic similarity (1.0). Requires an embedder to\nbe configured in the index settings."
              }
            ]
          },
          "filter": {
            "description": "Filter expression to apply before facet search"
          },
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy",
            "description": "Strategy used to match query terms"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Restrict search to specified attributes"
          },
          "ranking_score_threshold": {
            "type": [
              "number",
              "null"
            ],
            "format": "double",
            "description": "Minimum ranking score threshold (0.0 to 1.0) that documents must\nachieve to be considered when computing facet counts. Documents with\nscores below this threshold are excluded from facet value counts."
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            },
            "description": "Languages to use for query processing"
          },
          "exhaustive_facet_count": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Return exhaustive facet count instead of an estimate"
          }
        }
      },
      "FacetStats": {
        "type": "object",
        "description": "The numeric min and max values for a facet",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "number",
            "format": "double",
            "description": "Minimum value of the numeric facet"
          },
          "max": {
            "type": "number",
            "format": "double",
            "description": "Maximum value of the numeric facet"
          }
        }
      },
      "FacetValuesSort": {
        "type": "string",
        "enum": [
          "alpha",
          "count"
        ]
      },
      "FacetingSettings": {
        "type": "object",
        "description": "Faceting configuration settings",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of facet values returned for each facet",
            "example": 10,
            "minimum": 0
          },
          "sortFacetValuesBy": {
            "type": [
              "object",
              "null"
            ],
            "description": "How facet values should be sorted (by count or alphabetically)",
            "additionalProperties": {
              "$ref": "#/components/schemas/FacetValuesSort"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "genre": "count"
            }
          }
        },
        "additionalProperties": false
      },
      "FederatedFacets": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/ComputedFacets"
        },
        "propertyNames": {
          "type": "string"
        }
      },
      "FederatedSearch": {
        "type": "object",
        "description": "Request body for federated multi-search across multiple indexes. This\nallows you to execute multiple search queries in a single request and\noptionally combine their results into a unified response. Use this for\ncross-index search scenarios or to reduce network round-trips.",
        "required": [
          "queries"
        ],
        "properties": {
          "queries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchQueryWithIndex"
            },
            "description": "An array of search queries to execute. Each query can target a\ndifferent index and have its own parameters. When `federation` is\n`null`, results are returned separately for each query. When\n`federation` is set, results are merged."
          },
          "federation": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Federation",
                "description": "Configuration for combining results from multiple queries into a\nsingle response. When set, results are merged and ranked together.\nWhen `null`, each query's results are returned separately in an\narray."
              }
            ]
          }
        }
      },
      "FederatedSearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo",
            "description": "Pagination information"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                },
                "description": "Combined search results from all queries"
              },
              "queryVectors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/Vec"
                },
                "propertyNames": {
                  "type": "integer",
                  "minimum": 0
                }
              },
              "processingTimeMs": {
                "type": "integer",
                "description": "Total processing time in milliseconds",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "integer",
                    "format": "u-int64",
                    "minimum": 0
                  },
                  "propertyNames": {
                    "type": "string"
                  }
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "Merged facet statistics across all indexes",
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetsByIndex": {
                "$ref": "#/components/schemas/FederatedFacets",
                "description": "Facets grouped by index"
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid",
                "description": "Unique identifier for the request"
              },
              "metadata": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/components/schemas/SearchMetadata"
                },
                "description": "Metadata for each query"
              },
              "remoteErrors": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "Errors from remote servers",
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "minimum": 0
              },
              "performanceDetails": {}
            }
          }
        ],
        "description": "Response from a federated multi-search query"
      },
      "Federation": {
        "type": "object",
        "description": "Configuration for federated multi-search",
        "required": [
          "limit",
          "offset",
          "facetsByIndex",
          "showPerformanceDetails"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "description": "Maximum number of results to return across all queries",
            "minimum": 0
          },
          "offset": {
            "type": "integer",
            "description": "Number of results to skip",
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "hitsPerPage": {
            "type": [
              "integer",
              "null"
            ],
            "minimum": 0
          },
          "facetsByIndex": {
            "type": "object",
            "description": "Facets to retrieve per index",
            "additionalProperties": {
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string",
              "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
              "example": "movies"
            }
          },
          "mergeFacets": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MergeFacets",
                "description": "Options for merging facets from multiple indexes"
              }
            ]
          },
          "showPerformanceDetails": {
            "type": "boolean",
            "description": "Whether to include performance details in the response"
          }
        }
      },
      "FederationOptions": {
        "type": "object",
        "description": "Options for federated multi-search queries",
        "required": [
          "weight"
        ],
        "properties": {
          "weight": {
            "type": "number",
            "format": "double",
            "description": "Weight to apply to results from this query (default: 1.0)"
          },
          "remote": {
            "type": [
              "string",
              "null"
            ],
            "description": "Remote server to send this query to"
          },
          "queryPosition": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Position of this query in the list of queries",
            "minimum": 0
          }
        }
      },
      "Field": {
        "type": "object",
        "required": [
          "name",
          "displayed",
          "searchable",
          "sortable",
          "distinct",
          "rankingRule",
          "filterable",
          "localized"
        ],
        "properties": {
          "name": {
            "type": "string"
          },
          "displayed": {
            "$ref": "#/components/schemas/FieldDisplayConfig"
          },
          "searchable": {
            "$ref": "#/components/schemas/FieldSearchConfig"
          },
          "sortable": {
            "$ref": "#/components/schemas/FieldSortableConfig"
          },
          "distinct": {
            "$ref": "#/components/schemas/FieldDistinctConfig"
          },
          "rankingRule": {
            "$ref": "#/components/schemas/FieldRankingRuleConfig"
          },
          "filterable": {
            "$ref": "#/components/schemas/FieldFilterableConfig"
          },
          "localized": {
            "$ref": "#/components/schemas/FieldLocalizedConfig"
          }
        }
      },
      "FieldDisplayConfig": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        }
      },
      "FieldDistinctConfig": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        }
      },
      "FieldFilterableConfig": {
        "type": "object",
        "required": [
          "enabled",
          "sortBy",
          "facetSearch",
          "equality",
          "comparison"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "sortBy": {
            "$ref": "#/components/schemas/FacetValuesSort"
          },
          "facetSearch": {
            "type": "boolean"
          },
          "equality": {
            "type": "boolean"
          },
          "comparison": {
            "type": "boolean"
          }
        }
      },
      "FieldLocalizedConfig": {
        "type": "object",
        "required": [
          "locales"
        ],
        "properties": {
          "locales": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "FieldRankingRuleConfig": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "order": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "FieldSearchConfig": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        }
      },
      "FieldSortableConfig": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        }
      },
      "FilterFeatures": {
        "type": "object",
        "description": "Controls which filter operators are allowed for an attribute. This\nprovides fine-grained control over filtering capabilities.",
        "properties": {
          "equality": {
            "type": "boolean",
            "description": "When `true`, enables equality operators: `=`, `!=`, and `IN`. These\nallow filtering for exact matches or membership in a set of values.\nAlso enables `IS EMPTY`, `IS NULL`, and `EXISTS` operators. Defaults\nto `true`."
          },
          "comparison": {
            "type": "boolean",
            "description": "When `true`, enables comparison operators: `<`, `>`, `<=`, `>=`, and\n`TO` (range). These allow filtering based on numeric or string\ncomparisons. Defaults to `false`."
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesFeatures": {
        "type": "object",
        "description": "Controls which filtering and faceting operations are enabled for matching\nattributes. This allows restricting certain operations on specific fields\nfor security or performance reasons.",
        "properties": {
          "facetSearch": {
            "type": "boolean",
            "description": "When `true`, allows searching within facet values for matching\nattributes. This enables the facet search feature which lets users\nsearch for specific facet values. Defaults to `false`."
          },
          "filter": {
            "$ref": "#/components/schemas/FilterFeatures",
            "description": "Controls which filter operators are allowed for matching attributes.\nSee `FilterFeatures` for available options."
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesPatterns": {
        "type": "object",
        "description": "Defines a set of attribute patterns with specific filtering and faceting\nfeatures. This allows fine-grained control over which operations are\nallowed on matched attributes.",
        "required": [
          "attributePatterns"
        ],
        "properties": {
          "attributePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Patterns to match attribute names. Use `*` as a wildcard to match any\ncharacters. For example, `[\"price_*\", \"stock\"]` matches `price_usd`,\n`price_eur`, and `stock`."
          },
          "features": {
            "$ref": "#/components/schemas/FilterableAttributesFeatures",
            "description": "The filtering and faceting features enabled for attributes matching\nthese patterns. If not specified, defaults to equality filtering\nenabled."
          }
        },
        "additionalProperties": false
      },
      "FilterableAttributesRule": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/FilterableAttributesPatterns"
          }
        ]
      },
      "GetLogs": {
        "type": "object",
        "description": "Request body for streaming logs",
        "required": [
          "target",
          "mode",
          "profileMemory"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Log targets to filter. Format: code_part=log_level (e.g.,\nmilli=trace,actix_web=off)",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          },
          "mode": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/LogMode",
                "description": "Output format for log entries. `human` provides readable text output,\n`json` provides structured JSON for parsing, and `profile` outputs\nFirefox profiler format for performance visualization."
              }
            ],
            "default": "Human"
          },
          "profileMemory": {
            "type": "boolean",
            "description": "Enable memory profiling (only useful with profile mode, significantly\nslows down the engine)",
            "default": false
          }
        }
      },
      "HealthResponse": {
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus",
            "description": "The status of the instance."
          }
        }
      },
      "HealthStatus": {
        "type": "string",
        "enum": [
          "available"
        ]
      },
      "HitsInfo": {
        "oneOf": [
          {
            "type": "object",
            "description": "Finite pagination with exact counts",
            "required": [
              "hitsPerPage",
              "page",
              "totalPages",
              "totalHits"
            ],
            "properties": {
              "hitsPerPage": {
                "type": "integer",
                "description": "Number of results on each page",
                "minimum": 0
              },
              "page": {
                "type": "integer",
                "description": "Current search results page",
                "minimum": 0
              },
              "totalPages": {
                "type": "integer",
                "description": "Exhaustive total number of search result pages",
                "minimum": 0
              },
              "totalHits": {
                "type": "integer",
                "description": "Exhaustive total number of matches",
                "minimum": 0
              }
            }
          },
          {
            "type": "object",
            "description": "Offset-based pagination with estimated counts",
            "required": [
              "limit",
              "offset",
              "estimatedTotalHits"
            ],
            "properties": {
              "limit": {
                "type": "integer",
                "description": "Number of documents to take",
                "minimum": 0
              },
              "offset": {
                "type": "integer",
                "description": "Number of documents skipped",
                "minimum": 0
              },
              "estimatedTotalHits": {
                "type": "integer",
                "description": "Estimated total number of matches",
                "minimum": 0
              }
            }
          }
        ],
        "description": "Pagination information for search results"
      },
      "HybridQuery": {
        "type": "object",
        "description": "Configuration for hybrid search combining keyword and semantic search.\n\nThis allows searches that understand both exact words and conceptual\nmeaning.",
        "required": [
          "embedder"
        ],
        "properties": {
          "semanticRatio": {
            "type": "number",
            "format": "float",
            "description": "Controls the balance between keyword search and semantic search.\nA value of `0.0` uses only keyword search, `1.0` uses only semantic\nsearch, and `0.5` (the default) gives equal weight to both.\nUse lower values for exact term matching and higher values for\nconceptual similarity."
          },
          "embedder": {
            "type": "string",
            "description": "The name of the embedder configuration to use for generating query\nvectors. This must match one of the embedders defined in the index's\n`embedders` settings."
          }
        }
      },
      "ImportData": {
        "type": "object",
        "description": "Import data stored in a task",
        "required": [
          "remoteName",
          "documentCount"
        ],
        "properties": {
          "remoteName": {
            "type": "string",
            "description": "Remote that this task is imported from"
          },
          "indexName": {
            "type": [
              "string",
              "null"
            ],
            "description": "Index relevant to this task"
          },
          "documentCount": {
            "type": "integer",
            "format": "u-int64",
            "description": "Number of documents in this task",
            "minimum": 0
          }
        }
      },
      "IndexCreateRequest": {
        "type": "object",
        "description": "Request body for creating a new index",
        "required": [
          "uid"
        ],
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/IndexUid",
            "description": "Unique identifier for the index"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "Primary key of the index",
            "example": "id"
          }
        }
      },
      "IndexStats": {
        "type": "object",
        "description": "Stats of an `Index`, as known to the `stats` route.",
        "required": [
          "numberOfDocuments",
          "rawDocumentDbSize",
          "avgDocumentSize",
          "isIndexing",
          "fieldDistribution"
        ],
        "properties": {
          "numberOfDocuments": {
            "type": "integer",
            "format": "u-int64",
            "description": "Number of documents in the index",
            "minimum": 0
          },
          "rawDocumentDbSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Size of the documents database, in bytes.",
            "minimum": 0
          },
          "avgDocumentSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Average size of a document in the documents database.",
            "minimum": 0
          },
          "isIndexing": {
            "type": "boolean",
            "description": "Whether or not the index is currently ingesting document"
          },
          "numberOfEmbeddings": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embeddings in the index",
            "minimum": 0
          },
          "numberOfEmbeddedDocuments": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Number of embedded documents in the index",
            "minimum": 0
          },
          "fieldDistribution": {
            "type": "object",
            "description": "Association of every field name with the number of times it occurs in\nthe documents.",
            "additionalProperties": {
              "type": "integer",
              "format": "u-int64",
              "minimum": 0
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "IndexSwap": {
        "type": "object",
        "description": "Index swap operation",
        "required": [
          "indexes"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Pair of index UIDs to swap",
            "example": [
              "indexA",
              "indexB"
            ]
          },
          "rename": {
            "type": "boolean",
            "description": "Whether this is a rename operation"
          }
        }
      },
      "IndexUid": {
        "type": "string",
        "description": "An index uid is composed of only ascii alphanumeric characters, - and _, between 1 and 400\nbytes long",
        "example": "movies"
      },
      "IndexView": {
        "type": "object",
        "description": "An index containing searchable documents",
        "required": [
          "uid",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "uid": {
            "type": "string",
            "description": "Unique identifier for the index. Once created, it cannot be changed"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "Creation date of the index, represented in RFC 3339 format"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Latest date of index update, represented in RFC 3339 format"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "Primary key of the index"
          }
        }
      },
      "KeyView": {
        "type": "object",
        "description": "Represents an API key used for authenticating requests to Meilisearch.\nEach key has specific permissions defined by its actions and can be scoped\nto particular indexes. Keys provide fine-grained access control for your\nMeilisearch instance.",
        "required": [
          "key",
          "uid",
          "actions",
          "indexes",
          "createdAt",
          "updatedAt"
        ],
        "properties": {
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "A human-readable name for the API key. Use this to identify the purpose\nof each key, such as \"Frontend Search Key\" or \"Admin Key for CI/CD\".\nThis is optional and can be `null`."
          },
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A longer description explaining the purpose or usage of this API key.\nUseful for documenting why the key was created and how it should be\nused. This is optional and can be `null`."
          },
          "key": {
            "type": "string",
            "description": "The actual API key string to use in the `Authorization: Bearer <key>`\nheader when making requests to Meilisearch. Keep this value secret and\nnever expose it in client-side code."
          },
          "uid": {
            "type": "string",
            "format": "uuid",
            "description": "The unique identifier (UUID) for this API key. Use this to update or\ndelete the key. The UID remains constant even if the key's name or\ndescription changes."
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Action"
            },
            "description": "The list of actions (permissions) this key is allowed to perform.\nExamples include `documents.add`, `search`, `indexes.create`,\n`settings.update`, etc. Use `*` to grant all permissions."
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The list of index UIDs this key can access. Use `*` to grant access to\nall indexes, including future ones. Patterns are also supported, e.g.,\n`movies_*` matches any index starting with \"movies_\"."
          },
          "expiresAt": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "The expiration date and time of the key in RFC 3339 format. After this\ntime, the key will no longer be valid for authentication. Set to `null`\nfor keys that never expire."
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date and time when this API key was created, formatted as an\nRFC 3339 date-time string. This is automatically set by Meilisearch\nand cannot be modified.",
            "readOnly": true
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "description": "The date and time when this API key was last modified, formatted as an\nRFC 3339 date-time string. This is automatically updated by Meilisearch\nwhen the key's name or description changes.",
            "readOnly": true
          }
        }
      },
      "Kind": {
        "type": "string",
        "description": "The type of the task.",
        "enum": [
          "documentAdditionOrUpdate",
          "documentEdition",
          "documentDeletion",
          "settingsUpdate",
          "indexCreation",
          "indexDeletion",
          "indexUpdate",
          "indexSwap",
          "taskCancelation",
          "taskDeletion",
          "dumpCreation",
          "snapshotCreation",
          "export",
          "upgradeDatabase",
          "indexCompaction",
          "networkTopologyChange"
        ],
        "example": "documentAdditionOrUpdate"
      },
      "ListFields": {
        "type": "object",
        "description": "Request body for listing index fields with optional pagination and filtering.",
        "required": [
          "offset",
          "limit"
        ],
        "properties": {
          "offset": {
            "type": "integer",
            "description": "Number of fields to skip. Defaults to 0.",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of fields to return. Defaults to 20.",
            "minimum": 0
          },
          "filter": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ListFieldsFilter",
                "description": "Optional filter to restrict which fields are returned (e.g. by attribute patterns or by capability: displayed, searchable, sortable, filterable, etc.)."
              }
            ]
          }
        }
      },
      "ListFieldsFilter": {
        "type": "object",
        "description": "Filter fields by attribute name patterns or by capability (displayed, searchable, sortable, etc.). All criteria are ANDed.",
        "properties": {
          "attribute_patterns": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/AttributePatterns",
                "description": "Only include fields whose names match these patterns (e.g. `[\"title\", \"desc*\"]`)."
              }
            ]
          },
          "displayed": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that are displayed (true) or not displayed (false) in search results."
          },
          "searchable": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that are searchable (true) or not searchable (false)."
          },
          "sortable": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that are sortable (true) or not sortable (false)."
          },
          "distinct": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that are used as distinct attribute (true) or not (false)."
          },
          "ranking_rule": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that have a custom ranking rule (asc/desc) (true) or not (false)."
          },
          "filterable": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Only include fields that are filterable (true) or not filterable (false)."
          }
        }
      },
      "Locale": {
        "type": "string",
        "enum": [
          "af",
          "ak",
          "am",
          "ar",
          "az",
          "be",
          "bn",
          "bg",
          "ca",
          "cs",
          "da",
          "de",
          "el",
          "en",
          "eo",
          "et",
          "fi",
          "fr",
          "gu",
          "he",
          "hi",
          "hr",
          "hu",
          "hy",
          "id",
          "it",
          "jv",
          "ja",
          "kn",
          "ka",
          "km",
          "ko",
          "la",
          "lv",
          "lt",
          "ml",
          "mr",
          "mk",
          "my",
          "ne",
          "nl",
          "nb",
          "or",
          "pa",
          "fa",
          "pl",
          "pt",
          "ro",
          "ru",
          "si",
          "sk",
          "sl",
          "sn",
          "es",
          "sr",
          "sv",
          "ta",
          "te",
          "tl",
          "th",
          "tk",
          "tr",
          "uk",
          "ur",
          "uz",
          "vi",
          "yi",
          "zh",
          "zu",
          "afr",
          "aka",
          "amh",
          "ara",
          "aze",
          "bel",
          "ben",
          "bul",
          "cat",
          "ces",
          "dan",
          "deu",
          "ell",
          "eng",
          "epo",
          "est",
          "fin",
          "fra",
          "guj",
          "heb",
          "hin",
          "hrv",
          "hun",
          "hye",
          "ind",
          "ita",
          "jav",
          "jpn",
          "kan",
          "kat",
          "khm",
          "kor",
          "lat",
          "lav",
          "lit",
          "mal",
          "mar",
          "mkd",
          "mya",
          "nep",
          "nld",
          "nob",
          "ori",
          "pan",
          "pes",
          "pol",
          "por",
          "ron",
          "rus",
          "sin",
          "slk",
          "slv",
          "sna",
          "spa",
          "srp",
          "swe",
          "tam",
          "tel",
          "tgl",
          "tha",
          "tuk",
          "tur",
          "ukr",
          "urd",
          "uzb",
          "vie",
          "yid",
          "zho",
          "zul",
          "cmn"
        ]
      },
      "LocalizedAttributesRuleView": {
        "type": "object",
        "description": "Defines a rule for associating specific locales (languages) with\nattributes. This allows Meilisearch to use language-specific tokenization\nand processing for matched attributes, improving search quality for\nmultilingual content.",
        "required": [
          "attributePatterns",
          "locales"
        ],
        "properties": {
          "attributePatterns": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Patterns to match attribute names. Use `*` as a wildcard to match any\ncharacters. For example, `[\"title_*\", \"description\"]` matches\n`title_en`, `title_fr`, and `description`.",
            "example": [
              "*_ja"
            ]
          },
          "locales": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Locale"
            },
            "description": "The list of locales (languages) to apply to matching attributes. When\nthese attributes are indexed, Meilisearch will use language-specific\ntokenization rules. Examples: `[\"en\", \"fr\"]` or `[\"jpn\", \"zho\"]`."
          }
        }
      },
      "LogMode": {
        "type": "string",
        "description": "Format for log output",
        "enum": [
          "human",
          "json",
          "profile"
        ]
      },
      "MatchBounds": {
        "type": "object",
        "description": "Represents the position of a matching term in a document field. Used to\nindicate where query terms were found within attribute values, enabling\nfeatures like highlighting and match position display.",
        "required": [
          "start",
          "length"
        ],
        "properties": {
          "start": {
            "type": "integer",
            "description": "The byte offset where the match begins within the attribute value.\nThis is a zero-indexed position from the start of the string.",
            "minimum": 0
          },
          "length": {
            "type": "integer",
            "description": "The length in bytes of the matched text. Combined with `start`, this\ndefines the exact substring that matched the query term.",
            "minimum": 0
          },
          "indices": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "integer",
              "minimum": 0
            },
            "description": "Byte indices of individual matched characters when the match spans\nmultiple positions (e.g., for prefix matches). This is `null` for\nsimple contiguous matches."
          }
        }
      },
      "MatchingStrategy": {
        "type": "string",
        "description": "This is unfortunately a duplication of the struct in <meilisearch/src/search/mod.rs>.\nThe reason why it is duplicated is because milli cannot depend on meilisearch. It would be cyclic imports.",
        "enum": [
          "last",
          "all",
          "frequency"
        ]
      },
      "MergeFacets": {
        "type": "object",
        "description": "Options for merging facets from multiple indexes in federated search.\nWhen multiple indexes are queried, this controls how their facet values\nare combined into a single facet distribution.",
        "properties": {
          "maxValuesPerFacet": {
            "type": [
              "integer",
              "null"
            ],
            "description": "The maximum number of facet values to return for each facet after\nmerging. Values from all indexes are combined and sorted before\ntruncation. If not specified, uses the default limit from the index\nsettings.",
            "minimum": 0
          }
        }
      },
      "MinWordSizeTyposSetting": {
        "type": "object",
        "description": "Configures the minimum word length required before typos are allowed.\n\nThis helps prevent matching very short words with typos, which can lead\nto irrelevant results.",
        "properties": {
          "oneTypo": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "description": "The minimum word length required to accept one typo. Words shorter\nthan this value must match exactly. For example, if set to `5`, the\nword \"apple\" (5 letters) can have one typo, but \"app\" (3 letters)\ncannot. Defaults to `5`.",
            "example": 5,
            "minimum": 0
          },
          "twoTypos": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int8",
            "description": "The minimum word length required to accept two typos. Words shorter\nthan this value can have at most one typo. For example, if set to `9`,\nthe word \"computing\" (9 letters) can have two typos. Must be greater\nthan or equal to `oneTypo`. Defaults to `9`.",
            "example": 9,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "Network": {
        "type": "object",
        "description": "Network topology configuration for distributed Meilisearch",
        "properties": {
          "remotes": {
            "type": [
              "object",
              "null"
            ],
            "description": "Map of remote instance names to their configurations",
            "additionalProperties": {
              "$ref": "#/components/schemas/Remote"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "ms-00": {
                "url": "http://localhost:7700"
              },
              "ms-01": {
                "url": "http://localhost:7701"
              }
            }
          },
          "self": {
            "type": [
              "string",
              "null"
            ],
            "description": "Name of this instance in the network",
            "example": "ms-00"
          },
          "leader": {
            "type": [
              "string",
              "null"
            ],
            "description": "Name of the leader instance in the network",
            "example": "ms-00"
          },
          "previousRemotes": {
            "type": [
              "object",
              "null"
            ],
            "description": "Previous remote configurations (for rollback)",
            "additionalProperties": {
              "$ref": "#/components/schemas/Remote"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "ms-00": {
                "url": "http://localhost:7700"
              },
              "ms-01": {
                "url": "http://localhost:7701"
              }
            }
          }
        }
      },
      "Origin": {
        "type": "object",
        "description": "Information about the origin of a task in a distributed Meilisearch\ndeployment. This tracks where a task was originally created before being\nreplicated to other nodes.",
        "required": [
          "remoteName",
          "taskUid"
        ],
        "properties": {
          "remoteName": {
            "type": "string",
            "description": "The name of the remote Meilisearch instance where this task originated.\nThis corresponds to a remote defined in the network configuration."
          },
          "taskUid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The unique task identifier on the originating remote. This allows\ntracking the same task across different nodes in the network.",
            "minimum": 0
          },
          "networkVersion": {
            "type": "string",
            "format": "uuid",
            "description": "The version of the network topology when this task was created. Used to\nensure consistent task routing during network topology changes."
          }
        }
      },
      "OverridePooling": {
        "type": "string",
        "enum": [
          "useModel",
          "forceCls",
          "forceMean"
        ]
      },
      "PaginationSettings": {
        "type": "object",
        "description": "Pagination configuration settings",
        "properties": {
          "maxTotalHits": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of hits that can be returned",
            "example": 250,
            "minimum": 0
          }
        },
        "additionalProperties": false
      },
      "PaginationView_Field": {
        "type": "object",
        "description": "Paginated response wrapper",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name",
                "displayed",
                "searchable",
                "sortable",
                "distinct",
                "rankingRule",
                "filterable",
                "localized"
              ],
              "properties": {
                "name": {
                  "type": "string"
                },
                "displayed": {
                  "$ref": "#/components/schemas/FieldDisplayConfig"
                },
                "searchable": {
                  "$ref": "#/components/schemas/FieldSearchConfig"
                },
                "sortable": {
                  "$ref": "#/components/schemas/FieldSortableConfig"
                },
                "distinct": {
                  "$ref": "#/components/schemas/FieldDistinctConfig"
                },
                "rankingRule": {
                  "$ref": "#/components/schemas/FieldRankingRuleConfig"
                },
                "filterable": {
                  "$ref": "#/components/schemas/FieldFilterableConfig"
                },
                "localized": {
                  "$ref": "#/components/schemas/FieldLocalizedConfig"
                }
              }
            },
            "description": "Array of items for the current page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of items skipped",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of items returned",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "description": "Total number of items matching the query",
            "minimum": 0
          }
        }
      },
      "PaginationView_IndexView": {
        "type": "object",
        "description": "Paginated response wrapper",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "An index containing searchable documents",
              "required": [
                "uid",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "uid": {
                  "type": "string",
                  "description": "Unique identifier for the index. Once created, it cannot be changed"
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Creation date of the index, represented in RFC 3339 format"
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Latest date of index update, represented in RFC 3339 format"
                },
                "primaryKey": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Primary key of the index"
                }
              }
            },
            "description": "Array of items for the current page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of items skipped",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of items returned",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "description": "Total number of items matching the query",
            "minimum": 0
          }
        }
      },
      "PaginationView_KeyView": {
        "type": "object",
        "description": "Paginated response wrapper",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "type": "object",
              "description": "Represents an API key used for authenticating requests to Meilisearch.\nEach key has specific permissions defined by its actions and can be scoped\nto particular indexes. Keys provide fine-grained access control for your\nMeilisearch instance.",
              "required": [
                "key",
                "uid",
                "actions",
                "indexes",
                "createdAt",
                "updatedAt"
              ],
              "properties": {
                "name": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "A human-readable name for the API key. Use this to identify the purpose\nof each key, such as \"Frontend Search Key\" or \"Admin Key for CI/CD\".\nThis is optional and can be `null`."
                },
                "description": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "A longer description explaining the purpose or usage of this API key.\nUseful for documenting why the key was created and how it should be\nused. This is optional and can be `null`."
                },
                "key": {
                  "type": "string",
                  "description": "The actual API key string to use in the `Authorization: Bearer <key>`\nheader when making requests to Meilisearch. Keep this value secret and\nnever expose it in client-side code."
                },
                "uid": {
                  "type": "string",
                  "format": "uuid",
                  "description": "The unique identifier (UUID) for this API key. Use this to update or\ndelete the key. The UID remains constant even if the key's name or\ndescription changes."
                },
                "actions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Action"
                  },
                  "description": "The list of actions (permissions) this key is allowed to perform.\nExamples include `documents.add`, `search`, `indexes.create`,\n`settings.update`, etc. Use `*` to grant all permissions."
                },
                "indexes": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "The list of index UIDs this key can access. Use `*` to grant access to\nall indexes, including future ones. Patterns are also supported, e.g.,\n`movies_*` matches any index starting with \"movies_\"."
                },
                "expiresAt": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "format": "date-time",
                  "description": "The expiration date and time of the key in RFC 3339 format. After this\ntime, the key will no longer be valid for authentication. Set to `null`\nfor keys that never expire."
                },
                "createdAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date and time when this API key was created, formatted as an\nRFC 3339 date-time string. This is automatically set by Meilisearch\nand cannot be modified.",
                  "readOnly": true
                },
                "updatedAt": {
                  "type": "string",
                  "format": "date-time",
                  "description": "The date and time when this API key was last modified, formatted as an\nRFC 3339 date-time string. This is automatically updated by Meilisearch\nwhen the key's name or description changes.",
                  "readOnly": true
                }
              }
            },
            "description": "Array of items for the current page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of items skipped",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of items returned",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "description": "Total number of items matching the query",
            "minimum": 0
          }
        }
      },
      "PaginationView_Value": {
        "type": "object",
        "description": "Paginated response wrapper",
        "required": [
          "results",
          "offset",
          "limit",
          "total"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {},
            "description": "Array of items for the current page"
          },
          "offset": {
            "type": "integer",
            "description": "Number of items skipped",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of items returned",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "description": "Total number of items matching the query",
            "minimum": 0
          }
        }
      },
      "PatchApiKey": {
        "type": "object",
        "description": "Request body for updating an existing API key. Only the name and\ndescription can be modified - other properties like actions, indexes,\nand expiration are immutable after creation.",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ],
            "description": "A new description for the API key. Pass `null` to remove the existing\ndescription. Useful for documenting the purpose or usage of the key.",
            "example": "This key is used to update documents in the products index"
          },
          "name": {
            "type": [
              "string",
              "null"
            ],
            "description": "A new human-readable name for the API key. Pass `null` to remove the\nexisting name. Use this to identify keys by purpose, such as\n\"Production Search Key\" or \"CI/CD Indexing Key\".",
            "example": "Indexing Products API key"
          }
        }
      },
      "Personalize": {
        "type": "object",
        "description": "Configuration for personalized search results.\n\nWhen enabled, search results are tailored based on user context,\nproviding different rankings and results for different user profiles.",
        "required": [
          "user_context"
        ],
        "properties": {
          "user_context": {
            "type": "string",
            "description": "A string describing the user context for personalization. This is\npassed to the embedder to generate user-specific vectors that\ninfluence search ranking. Example: user preferences, browsing\nhistory, or demographic information."
          }
        }
      },
      "PrefixSearchSettings": {
        "type": "string",
        "enum": [
          "indexingTime",
          "disabled"
        ]
      },
      "ProgressStepView": {
        "type": "object",
        "description": "Information about a single processing step within a batch or task. Each\nstep has a name, current progress, and total items to process.",
        "required": [
          "currentStep",
          "finished",
          "total"
        ],
        "properties": {
          "currentStep": {
            "type": "string",
            "description": "A human-readable name describing what this processing step is doing.\nExamples include \"indexing documents\", \"computing embeddings\",\n\"building word cache\", etc."
          },
          "finished": {
            "type": "integer",
            "format": "u-int32",
            "description": "The number of items that have been processed so far in this step.\nCompare with `total` to calculate the percentage complete for this\nspecific step.",
            "minimum": 0
          },
          "total": {
            "type": "integer",
            "format": "u-int32",
            "description": "The total number of items to process in this step. When `finished`\nequals `total`, this step is complete and processing moves to the\nnext step.",
            "minimum": 0
          }
        }
      },
      "ProgressView": {
        "type": "object",
        "description": "Real-time progress information for a batch or task that is currently\nbeing processed. Use this to display progress bars or status updates to\nusers.",
        "required": [
          "steps",
          "percentage"
        ],
        "properties": {
          "steps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProgressStepView"
            },
            "description": "A hierarchical list of processing steps currently being executed.\nSteps are listed from outermost to innermost, with each step\nrepresenting a more granular operation within its parent step."
          },
          "percentage": {
            "type": "number",
            "format": "float",
            "description": "The overall completion percentage of the operation (0.0 to 100.0).\nThis is calculated by combining the progress of all nested steps,\nweighted by their relative importance."
          }
        }
      },
      "ProximityPrecisionView": {
        "type": "string",
        "enum": [
          "byWord",
          "byAttribute"
        ]
      },
      "RankingRuleView": {
        "oneOf": [
          {
            "type": "string",
            "description": "Sorted by decreasing number of matched query terms.\nQuery words at the front of an attribute is considered better than if\nit was at the back.",
            "enum": [
              "Words"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing number of typos.",
            "enum": [
              "Typo"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by increasing distance between matched query terms.",
            "enum": [
              "Proximity"
            ]
          },
          {
            "type": "string",
            "description": "Documents with quey words contained in more important\nattributes are considered better.",
            "enum": [
              "Attribute"
            ]
          },
          {
            "type": "string",
            "description": "Dynamically sort at query time the documents. None, one or multiple\nAsc/Desc sortable attributes can be used in place of this criterion at\nquery time.",
            "enum": [
              "Sort"
            ]
          },
          {
            "type": "string",
            "description": "Sorted by the similarity of the matched words with the query words.",
            "enum": [
              "Exactness"
            ]
          },
          {
            "type": "object",
            "description": "Sorted by the increasing value of the field specified.",
            "required": [
              "Asc"
            ],
            "properties": {
              "Asc": {
                "type": "string",
                "description": "Sorted by the increasing value of the field specified."
              }
            }
          },
          {
            "type": "object",
            "description": "Sorted by the decreasing value of the field specified.",
            "required": [
              "Desc"
            ],
            "properties": {
              "Desc": {
                "type": "string",
                "description": "Sorted by the decreasing value of the field specified."
              }
            }
          }
        ]
      },
      "RankingScoreThreshold": {
        "type": "number",
        "format": "double"
      },
      "Remote": {
        "type": "object",
        "description": "Configuration for a remote Meilisearch instance",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL of the remote instance",
            "example": "http://localhost:7700"
          },
          "searchApiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "API key for search operations on this remote",
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          },
          "writeApiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "API key for write operations on this remote",
            "example": "XWnBI8QHUc-4IlqbKPLUDuhftNq19mQtjc6JvmivzJU"
          }
        }
      },
      "RemoteTask": {
        "type": "object",
        "description": "Represents a task that was replicated to a remote Meilisearch instance.\nContains either the remote task UID on success, or an error if\nreplication failed.",
        "properties": {
          "taskUid": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The unique task identifier assigned by the remote Meilisearch instance.\nPresent when the task was successfully replicated to the remote.",
            "minimum": 0
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError",
                "description": "Error details if the task failed to replicate to this remote. Contains\nthe error message, code, and type from the remote instance."
              }
            ]
          }
        }
      },
      "ResponseError": {
        "type": "object",
        "required": [
          "message",
          "code",
          "type",
          "link"
        ],
        "properties": {
          "message": {
            "type": "string",
            "description": "The error message."
          },
          "code": {
            "$ref": "#/components/schemas/Code",
            "description": "The error code."
          },
          "type": {
            "$ref": "#/components/schemas/ErrorType",
            "description": "The error type."
          },
          "link": {
            "type": "string",
            "description": "A link to the documentation about this specific error."
          }
        }
      },
      "RuntimeTogglableFeatures": {
        "type": "object",
        "description": "Experimental features that can be toggled at runtime",
        "properties": {
          "metrics": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable the /metrics endpoint for Prometheus metrics"
          },
          "logsRoute": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable the /logs route for log configuration"
          },
          "editDocumentsByFunction": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable document editing via JavaScript functions"
          },
          "containsFilter": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable the CONTAINS filter operator"
          },
          "network": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable network features for distributed search"
          },
          "getTaskDocumentsRoute": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable the route to get documents from tasks"
          },
          "compositeEmbedders": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable composite embedders for multi-source embeddings"
          },
          "chatCompletions": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable chat completion capabilities"
          },
          "multimodal": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable multimodal search with images and other media"
          },
          "vectorStoreSetting": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Enable vector store settings configuration"
          }
        }
      },
      "SearchHit": {
        "type": "object",
        "description": "A single search result hit",
        "properties": {
          "_formatted": {
            "type": "object",
            "description": "The formatted document with highlighted and cropped attributes",
            "additionalProperties": true
          },
          "_matchesPosition": {
            "type": [
              "object",
              "null"
            ],
            "description": "Location of matching terms in the document",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/MatchBounds"
              }
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "_rankingScore": {
            "type": [
              "number",
              "null"
            ],
            "format": "double",
            "description": "Global ranking score of the document"
          },
          "_rankingScoreDetails": {
            "type": [
              "object",
              "null"
            ],
            "description": "Detailed breakdown of the ranking score",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": {
          "description": "The document data"
        }
      },
      "SearchMetadata": {
        "type": "object",
        "description": "Metadata about a search query",
        "required": [
          "queryUid",
          "indexUid"
        ],
        "properties": {
          "queryUid": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the query"
          },
          "indexUid": {
            "type": "string",
            "description": "Identifier of the queried index"
          },
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "Primary key of the queried index"
          },
          "remote": {
            "type": [
              "string",
              "null"
            ],
            "description": "Remote server that processed the query"
          }
        }
      },
      "SearchQuery": {
        "type": "object",
        "required": [
          "offset",
          "limit",
          "retrieve_vectors",
          "crop_length",
          "show_matches_position",
          "show_ranking_score",
          "show_ranking_score_details",
          "show_performance_details",
          "highlight_pre_tag",
          "highlight_post_tag",
          "crop_marker",
          "matching_strategy"
        ],
        "properties": {
          "q": {
            "type": [
              "string",
              "null"
            ],
            "description": "Query string"
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            },
            "description": "Search using a custom query vector"
          },
          "media": {
            "description": "Perform AI-powered search queries with multimodal content"
          },
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery",
                "description": "Hybrid search configuration combining keyword and semantic search.\nSet `semanticRatio` to balance between keyword matching (0.0) and\nsemantic similarity (1.0). Requires an embedder to be configured."
              }
            ]
          },
          "offset": {
            "type": "integer",
            "description": "Number of documents to skip",
            "default": 0,
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of documents returned",
            "default": 20,
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Request a specific page of results",
            "minimum": 0
          },
          "hits_per_page": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of documents returned for a page",
            "minimum": 0
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to display in the returned documents",
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean",
            "description": "Return document and query vector data"
          },
          "attributes_to_crop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes whose values have to be cropped"
          },
          "crop_length": {
            "type": "integer",
            "description": "Maximum length of cropped value in words",
            "default": 10,
            "minimum": 0
          },
          "attributes_to_highlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Highlight matching terms contained in an attribute",
            "uniqueItems": true
          },
          "show_matches_position": {
            "type": "boolean",
            "description": "Return matching terms location"
          },
          "show_ranking_score": {
            "type": "boolean",
            "description": "Display the global ranking score of a document"
          },
          "show_ranking_score_details": {
            "type": "boolean",
            "description": "Adds a detailed global ranking score field"
          },
          "show_performance_details": {
            "type": "boolean",
            "description": "Adds a detailed performance details field"
          },
          "use_network": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Experimental: Whether this query should be performed on the whole network or locally.\n\nWhen performing the query on the whole network, this is \"as-if\" a remote federated search were performed,\nsuch that all shards are covered, and such that documents are deduplicated across the remotes.\n\n# Response\n\nThe response will have the same shape as a federated search response.\n\n# Edition\n\nThis feature is available in the Enterprise Edition.\n\n# Experimental\n\n- Setting this parameter to a value different from the default requires the `network` experimental feature.\n\n# Values\n\n- `Some(true)`: Use the whole network for this query.\n- `Some(false)`: Make this query local.\n- `None` (default): Same as `Some(false)`.\n\n# Assumptions when using the network\n\nNetwork queries assume that the following is true:\n\n- the target index exists with compatible settings on all remotes of the network.\n- any document with the same document id between two remotes have the same content and can be deduplicated."
          },
          "filter": {
            "description": "Filter queries by an attribute's value"
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Sort search results by an attribute's value"
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ],
            "description": "Restrict search to documents with unique values of specified\nattribute"
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Display the count of matches per facet"
          },
          "highlight_pre_tag": {
            "type": "string",
            "description": "String inserted at the start of a highlighted term",
            "default": "<em>"
          },
          "highlight_post_tag": {
            "type": "string",
            "description": "String inserted at the end of a highlighted term",
            "default": "</em>"
          },
          "crop_marker": {
            "type": "string",
            "description": "String marking crop boundaries",
            "default": ""
          },
          "matching_strategy": {
            "$ref": "#/components/schemas/MatchingStrategy",
            "description": "Strategy used to match query terms within documents"
          },
          "attributes_to_search_on": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Restrict search to the specified attributes"
          },
          "ranking_score_threshold": {
            "type": [
              "number",
              "null"
            ],
            "format": "double",
            "description": "Minimum ranking score threshold (0.0 to 1.0) that documents must\nachieve to be included in results. Documents with scores below this\nthreshold are excluded. Useful for filtering out low-relevance\nresults."
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            },
            "description": "Explicitly specify languages used in a query"
          },
          "personalize": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/Personalize",
                "description": "Enables personalized search results based on user context. When\nprovided, the search uses AI to tailor results to the user's\nprofile, preferences, or behavior described in `userContext`."
              }
            ]
          }
        }
      },
      "SearchQueryWithIndex": {
        "type": "object",
        "description": "A `SearchQuery` + an index UID and optional FederationOptions.",
        "required": [
          "indexUid",
          "retrieveVectors",
          "cropLength",
          "showRankingScore",
          "showRankingScoreDetails",
          "showMatchesPosition",
          "highlightPreTag",
          "highlightPostTag",
          "cropMarker",
          "matchingStrategy"
        ],
        "properties": {
          "indexUid": {
            "$ref": "#/components/schemas/IndexUid",
            "description": "Index unique identifier"
          },
          "q": {
            "type": [
              "string",
              "null"
            ],
            "description": "Query string"
          },
          "vector": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "number",
              "format": "float"
            },
            "description": "Search using a custom query vector"
          },
          "media": {
            "description": "Perform AI-powered search queries with multimodal content"
          },
          "hybrid": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/HybridQuery",
                "description": "Hybrid search configuration combining keyword and semantic search.\nSet `semanticRatio` to balance between keyword matching (0.0) and\nsemantic similarity (1.0). Requires an embedder to be configured."
              }
            ]
          },
          "offset": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Number of documents to skip",
            "minimum": 0
          },
          "limit": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of documents returned",
            "minimum": 0
          },
          "page": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Request a specific page of results",
            "minimum": 0
          },
          "hitsPerPage": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Maximum number of documents returned for a page",
            "minimum": 0
          },
          "attributesToRetrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to display in the returned documents",
            "uniqueItems": true
          },
          "retrieveVectors": {
            "type": "boolean",
            "description": "Return document and query vector data"
          },
          "attributesToCrop": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes whose values have to be cropped"
          },
          "cropLength": {
            "type": "integer",
            "description": "Maximum length of cropped value in words",
            "minimum": 0
          },
          "attributesToHighlight": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Highlight matching terms contained in an attribute",
            "uniqueItems": true
          },
          "showRankingScore": {
            "type": "boolean",
            "description": "Display the global ranking score of a document"
          },
          "showRankingScoreDetails": {
            "type": "boolean",
            "description": "Adds a detailed global ranking score field"
          },
          "showPerformanceDetails": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "Adds a detailed performance details field"
          },
          "useNetwork": {
            "type": [
              "boolean",
              "null"
            ]
          },
          "showMatchesPosition": {
            "type": "boolean",
            "description": "Return matching terms location"
          },
          "filter": {
            "description": "Filter queries by an attribute's value"
          },
          "sort": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Sort search results by an attribute's value"
          },
          "distinct": {
            "type": [
              "string",
              "null"
            ],
            "description": "Restrict search to documents with unique values of specified\nattribute"
          },
          "facets": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Display the count of matches per facet"
          },
          "highlightPreTag": {
            "type": "string",
            "description": "String inserted at the start of a highlighted term"
          },
          "highlightPostTag": {
            "type": "string",
            "description": "String inserted at the end of a highlighted term"
          },
          "cropMarker": {
            "type": "string",
            "description": "String marking crop boundaries"
          },
          "matchingStrategy": {
            "$ref": "#/components/schemas/MatchingStrategy",
            "description": "Strategy used to match query terms within documents"
          },
          "attributesToSearchOn": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Restrict search to the specified attributes"
          },
          "rankingScoreThreshold": {
            "type": [
              "number",
              "null"
            ],
            "format": "double",
            "description": "Exclude results below the specified ranking score"
          },
          "locales": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/Locale"
            },
            "description": "Languages to use for query tokenization"
          },
          "federationOptions": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FederationOptions",
                "description": "Federation options for multi-index search"
              }
            ]
          }
        }
      },
      "SearchResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo",
            "description": "Pagination information for the search results"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "query",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                },
                "description": "Results of the query"
              },
              "query": {
                "type": "string",
                "description": "Query originating the response"
              },
              "queryVector": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": "number",
                  "format": "float"
                },
                "description": "Vector representation of the query"
              },
              "processingTimeMs": {
                "type": "integer",
                "description": "Processing time of the query in milliseconds",
                "minimum": 0
              },
              "facetDistribution": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "Distribution of the given facets",
                "additionalProperties": {},
                "propertyNames": {
                  "type": "string"
                }
              },
              "facetStats": {
                "type": [
                  "object",
                  "null"
                ],
                "description": "The numeric min and max values per facet",
                "additionalProperties": {
                  "$ref": "#/components/schemas/FacetStats"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "requestUid": {
                "type": [
                  "string",
                  "null"
                ],
                "format": "uuid",
                "description": "A UUID v7 identifying the search request"
              },
              "metadata": {
                "oneOf": [
                  {
                    "type": "null"
                  },
                  {
                    "$ref": "#/components/schemas/SearchMetadata",
                    "description": "Metadata about the search query"
                  }
                ]
              },
              "performanceDetails": {
                "description": "Performance details of the search query"
              },
              "remoteErrors": {
                "type": [
                  "object",
                  "null"
                ],
                "additionalProperties": {
                  "$ref": "#/components/schemas/ResponseError"
                },
                "propertyNames": {
                  "type": "string"
                }
              },
              "semanticHitCount": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "u-int32",
                "description": "Exhaustive number of semantic search matches (only present in\nAI-powered searches)",
                "minimum": 0
              }
            }
          }
        ],
        "description": "Search response containing matching documents and metadata"
      },
      "SearchResultWithIndex": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SearchResult",
            "description": "Search results for this index"
          },
          {
            "type": "object",
            "required": [
              "indexUid"
            ],
            "properties": {
              "indexUid": {
                "type": "string",
                "description": "Identifier of the queried index"
              }
            }
          }
        ],
        "description": "Search result with index identifier for multi-search responses"
      },
      "SearchResults": {
        "type": "object",
        "description": "Response containing results from multiple search queries",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SearchResultWithIndex"
            },
            "description": "Array of search results for each query"
          }
        }
      },
      "SettingEmbeddingSettings": {
        "type": "object",
        "description": "\"Technical\" type that is required due to utoipa.\n\nWe did not find a way to implement [`utoipa::ToSchema`] for the\n[`Setting`] enum, but most types can use the `value_type` macro parameter\nto workaround that issue.\n\nHowever that type is used in the settings route, including through the\nmacro that auto-generate all the settings route, so we can't remap the\n`value_type`.",
        "properties": {
          "inner": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "type": "object",
                "properties": {
                  "source": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/EmbedderSource",
                        "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
                      }
                    ]
                  },
                  "model": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
                  },
                  "revision": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
                  },
                  "pooling": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/OverridePooling",
                        "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
                      }
                    ]
                  },
                  "apiKey": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
                  },
                  "dimensions": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
                  },
                  "binaryQuantized": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "Whether to binary quantize the embeddings of this embedder.\n\nBinary quantized embeddings are smaller than regular embeddings, which improves\ndisk usage and retrieval speed, at the cost of relevancy.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  When set to `true`, embeddings are not regenerated, but they are binary quantized, which takes time.\n\n# Defaults\n\n- Defaults to `false`\n\n# Note\n\nAs binary quantization is a destructive operation, it is not possible to disable again this setting after\nfirst enabling it. If you are unsure of whether the performance-relevancy tradeoff is right for you,\nwe recommend to use this parameter on a test index first."
                  },
                  "documentTemplate": {
                    "type": [
                      "boolean",
                      "null"
                    ],
                    "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
                  },
                  "documentTemplateMaxBytes": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
                    "minimum": 0
                  },
                  "url": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
                  },
                  "indexingFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchFragments": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {},
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "request": {
                    "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "response": {
                    "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
                  },
                  "headers": {
                    "type": [
                      "object",
                      "null"
                    ],
                    "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
                    "additionalProperties": {
                      "type": "string"
                    },
                    "propertyNames": {
                      "type": "string"
                    }
                  },
                  "searchEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "indexingEmbedder": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/SubEmbeddingSettings"
                      }
                    ]
                  },
                  "distribution": {
                    "oneOf": [
                      {
                        "type": "null"
                      },
                      {
                        "$ref": "#/components/schemas/DistributionShift",
                        "description": "Affine transformation applied to the semantic score to make it more comparable to the ranking score.\n\n# Availability\n\n- This parameter is available for all embedders\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            ],
            "description": "Configuration for this embedder. Includes the source (openAi,\nhuggingFace, ollama, rest, userProvided), model settings, API\ncredentials, and document template for generating embeddings."
          }
        }
      },
      "Settings_Checked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if\nthey represents settings whose validity is guaranteed, or `Unchecked` if\nthey need to be validated. In the later case, a call to `check` will\nreturn a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of\nimportance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering.\nSee [Filtering and Faceted\nSearch](https://meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is\ncustomizable. [A list of ordered built-in ranking\nrules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an\narray of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given\nfield.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Typo tolerance settings for controlling how Meilisearch handles\nspelling mistakes in search queries. Configure minimum word lengths,\ndisable on specific words or attributes."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings for controlling facet behavior. Configure maximum\nfacet values returned and sorting order for facet values."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings for controlling the maximum number of results\nthat can be returned. Set `maxTotalHits` to limit how far users can\npaginate into results."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "description": "Rules for associating locales (languages) with specific attributes.\nThis enables language-specific tokenization for multilingual content,\nimproving search quality for non-English text.",
            "example": [
              {
                "locales": [
                  "jpn"
                ],
                "attributePatterns": [
                  "*_ja"
                ]
              }
            ]
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "When `true`, enables facet search which allows users to search within\nfacet values. When `false`, only the first `maxValuesPerFacet` values\nare returned. Defaults to `true`.",
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings",
                "description": "Controls prefix search behavior. `indexingTime` enables prefix search\nby building a prefix database at indexing time. `disabled` turns off\nprefix search for faster indexing. Defaults to `indexingTime`."
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Chat settings for AI-powered search. Configure the index description,\ndocument template for rendering, and search parameters used when the\nLLM queries this index."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend",
                "description": "Backend storage for vector embeddings. `memory` stores vectors in\nmemory for fastest performance. `database` stores vectors on disk to\nreduce memory usage at the cost of speed."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Settings_Unchecked": {
        "type": "object",
        "description": "Holds all the settings for an index. `T` can either be `Checked` if\nthey represents settings whose validity is guaranteed, or `Unchecked` if\nthey need to be validated. In the later case, a call to `check` will\nreturn a `Settings<Checked>` from a `Settings<Unchecked>`.",
        "properties": {
          "displayedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields displayed in the returned documents.",
            "example": [
              "id",
              "title",
              "description",
              "url"
            ]
          },
          "searchableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Fields in which to search for matching query words sorted by order of\nimportance.",
            "example": [
              "title",
              "description"
            ]
          },
          "filterableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/FilterableAttributesRule"
            },
            "description": "Attributes to use for faceting and filtering.\nSee [Filtering and Faceted\nSearch](https://meilisearch.com/docs/learn/filtering_and_sorting/search_with_facet_filters).",
            "example": [
              "release_date",
              "genre"
            ]
          },
          "sortableAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to use when sorting search results.",
            "example": [
              "release_date"
            ]
          },
          "rankingRules": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of ranking rules sorted by order of importance. The order is\ncustomizable. [A list of ordered built-in ranking\nrules](https://www.meilisearch.com/docs/learn/relevancy/relevancy).",
            "example": [
              "words",
              "typo",
              "proximity",
              "attribute",
              "exactness"
            ]
          },
          "stopWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of words ignored when present in search queries.",
            "example": [
              "the",
              "a",
              "them",
              "their"
            ]
          },
          "nonSeparatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters not delimiting where one term begins and ends.",
            "example": [
              " ",
              "\n"
            ]
          },
          "separatorTokens": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of characters delimiting where one term begins and ends.",
            "example": [
              "S"
            ]
          },
          "dictionary": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "List of strings Meilisearch should parse as a single term.",
            "example": [
              "iPhone pro"
            ]
          },
          "synonyms": {
            "type": [
              "object",
              "null"
            ],
            "description": "List of associated words treated similarly. A word associated to an\narray of word as synonyms.",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "he": [
                "she",
                "they",
                "them"
              ],
              "phone": [
                "iPhone",
                "android"
              ]
            }
          },
          "distinctAttribute": {
            "type": [
              "string",
              "null"
            ],
            "description": "Search returns documents with distinct (different) values of the given\nfield.",
            "example": "sku"
          },
          "proximityPrecision": {
            "type": [
              "string",
              "null"
            ],
            "description": "Precision level when calculating the proximity ranking rule.",
            "example": "byAttribute"
          },
          "typoTolerance": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/TypoSettings",
                "description": "Typo tolerance settings for controlling how Meilisearch handles\nspelling mistakes in search queries. Configure minimum word lengths,\ndisable on specific words or attributes."
              }
            ]
          },
          "faceting": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/FacetingSettings",
                "description": "Faceting settings for controlling facet behavior. Configure maximum\nfacet values returned and sorting order for facet values."
              }
            ]
          },
          "pagination": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PaginationSettings",
                "description": "Pagination settings for controlling the maximum number of results\nthat can be returned. Set `maxTotalHits` to limit how far users can\npaginate into results."
              }
            ]
          },
          "embedders": {
            "type": [
              "object",
              "null"
            ],
            "description": "Embedder required for performing semantic search queries.",
            "additionalProperties": {
              "$ref": "#/components/schemas/SettingEmbeddingSettings"
            },
            "propertyNames": {
              "type": "string"
            }
          },
          "searchCutoffMs": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int64",
            "description": "Maximum duration of a search query.",
            "example": 50,
            "minimum": 0
          },
          "localizedAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/components/schemas/LocalizedAttributesRuleView"
            },
            "description": "Rules for associating locales (languages) with specific attributes.\nThis enables language-specific tokenization for multilingual content,\nimproving search quality for non-English text.",
            "example": [
              {
                "locales": [
                  "jpn"
                ],
                "attributePatterns": [
                  "*_ja"
                ]
              }
            ]
          },
          "facetSearch": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "When `true`, enables facet search which allows users to search within\nfacet values. When `false`, only the first `maxValuesPerFacet` values\nare returned. Defaults to `true`.",
            "example": true
          },
          "prefixSearch": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/PrefixSearchSettings",
                "description": "Controls prefix search behavior. `indexingTime` enables prefix search\nby building a prefix database at indexing time. `disabled` turns off\nprefix search for faster indexing. Defaults to `indexingTime`."
              }
            ]
          },
          "chat": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ChatSettings",
                "description": "Chat settings for AI-powered search. Configure the index description,\ndocument template for rendering, and search parameters used when the\nLLM queries this index."
              }
            ]
          },
          "vectorStore": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/VectorStoreBackend",
                "description": "Backend storage for vector embeddings. `memory` stores vectors in\nmemory for fastest performance. `database` stores vectors on disk to\nreduce memory usage at the cost of speed."
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "SimilarQuery": {
        "type": "object",
        "description": "Request body for similar document search",
        "required": [
          "id",
          "offset",
          "limit",
          "embedder",
          "retrieve_vectors",
          "show_ranking_score",
          "show_ranking_score_details",
          "show_performance_details",
          "ranking_score_threshold"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "Document ID to find similar documents for"
          },
          "offset": {
            "type": "integer",
            "description": "Number of documents to skip",
            "minimum": 0
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of documents returned",
            "minimum": 0
          },
          "filter": {
            "description": "Filter queries by an attribute's value"
          },
          "embedder": {
            "type": "string",
            "description": "Name of the embedder to use for semantic similarity"
          },
          "attributes_to_retrieve": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "Attributes to display in the returned documents",
            "uniqueItems": true
          },
          "retrieve_vectors": {
            "type": "boolean",
            "description": "Return document vector data"
          },
          "show_ranking_score": {
            "type": "boolean",
            "description": "Display the global ranking score of a document"
          },
          "show_ranking_score_details": {
            "type": "boolean",
            "description": "Adds a detailed global ranking score field"
          },
          "show_performance_details": {
            "type": "boolean",
            "description": "Adds a detailed performance details field"
          },
          "ranking_score_threshold": {
            "type": "number",
            "format": "double",
            "description": "Excludes results with low ranking scores"
          }
        }
      },
      "SimilarResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/HitsInfo",
            "description": "Pagination information"
          },
          {
            "type": "object",
            "required": [
              "hits",
              "id",
              "processingTimeMs"
            ],
            "properties": {
              "hits": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SearchHit"
                },
                "description": "Results of the query"
              },
              "id": {
                "type": "string",
                "description": "Document ID that was used as reference"
              },
              "processingTimeMs": {
                "type": "integer",
                "description": "Processing time of the query in milliseconds",
                "minimum": 0
              },
              "performanceDetails": {
                "description": "Performance details of the query"
              }
            }
          }
        ],
        "description": "Response containing similar documents"
      },
      "Stats": {
        "type": "object",
        "description": "Global statistics for the Meilisearch instance",
        "required": [
          "databaseSize",
          "usedDatabaseSize",
          "indexes"
        ],
        "properties": {
          "databaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Total disk space used by the database in bytes",
            "minimum": 0
          },
          "usedDatabaseSize": {
            "type": "integer",
            "format": "u-int64",
            "description": "Actual size of the data in the database in bytes",
            "minimum": 0
          },
          "lastUpdate": {
            "type": [
              "string",
              "null"
            ],
            "format": "date-time",
            "description": "Date of the last update in RFC 3339 format. Null if no update has been\nprocessed"
          },
          "indexes": {
            "type": "object",
            "description": "Statistics for each index",
            "additionalProperties": {
              "$ref": "#/components/schemas/IndexStats"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        }
      },
      "Status": {
        "type": "string",
        "description": "The status of a task.",
        "enum": [
          "enqueued",
          "processing",
          "succeeded",
          "failed",
          "canceled"
        ],
        "example": "processing"
      },
      "SubEmbeddingSettings": {
        "type": "object",
        "properties": {
          "source": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/EmbedderSource",
                "description": "The source used to provide the embeddings.\n\nWhich embedder parameters are available and mandatory is determined by the value of this setting.\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- Defaults to `openAi`"
              }
            ]
          },
          "model": {
            "type": [
              "string",
              "null"
            ],
            "description": "The name of the model to use.\n\n# Mandatory\n\n- This parameter is mandatory for source `ollama`\n\n# Availability\n\n- This parameter is available for sources `openAi`, `huggingFace`, `ollama`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings.\n\n# Defaults\n\n- For source `openAi`, defaults to `text-embedding-3-small`\n- For source `huggingFace`, defaults to `BAAI/bge-base-en-v1.5`"
          },
          "revision": {
            "type": [
              "string",
              "null"
            ],
            "description": "The revision (commit SHA1) of the model to use.\n\nIf unspecified, Meilisearch picks the latest revision of the model.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- When `model` is set to default, defaults to `617ca489d9e86b49b8167676d8220688b99db36e`\n- Otherwise, defaults to `null`"
          },
          "pooling": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/OverridePooling",
                "description": "The pooling method to use.\n\n# Availability\n\n- This parameter is available for source `huggingFace`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings\n\n# Defaults\n\n- Defaults to `useModel`\n\n# Compatibility Note\n\n- Embedders created before this parameter was available default to `forceMean` to preserve the existing behavior."
              }
            ]
          },
          "apiKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "The API key to pass to the remote embedder while making requests.\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the key is read from `OPENAI_API_KEY`, then `MEILI_OPENAI_API_KEY`.\n- For other sources, no bearer token is sent if this parameter is not set.\n\n# Note\n\n- This setting is partially hidden when returned by the settings"
          },
          "dimensions": {
            "type": [
              "string",
              "null"
            ],
            "description": "The expected dimensions of the embeddings produced by this embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `userProvided`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama`, `rest`, `userProvided`\n\n#  Reindexing\n\n-  When the source is `openAi`, changing the value of this parameter always regenerates embeddings\n-  For other sources, changing the value of this parameter never regenerates embeddings\n\n# Defaults\n\n- For source `openAi`, the dimensions is the maximum allowed by the model.\n- For sources `ollama` and `rest`, the dimensions are inferred by embedding a sample text."
          },
          "documentTemplate": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "A liquid template used to render documents to a text that can be embedded.\n\nMeillisearch interpolates the template for each document and sends the resulting text to the embedder.\nThe embedder then generates document vectors based on this text.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest\n\n#  Reindexing\n\n-  When modified, embeddings are regenerated for documents whose rendering through the template produces a different text."
          },
          "documentTemplateMaxBytes": {
            "type": [
              "integer",
              "null"
            ],
            "description": "Rendered texts are truncated to this size.\n\n# Availability\n\n- This parameter is available for source `openAi`, `huggingFace`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When increased, embeddings are regenerated for documents whose rendering through the template produces a different text.\n-  When decreased, embeddings are never regenerated\n\n# Default\n\n- Defaults to 400",
            "minimum": 0
          },
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL to reach the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `openAi`, `ollama` and `rest`\n\n#  Reindexing\n\n-  When modified for source `openAi`, embeddings are never regenerated\n-  When modified for sources `ollama` and `rest`, embeddings are always regenerated"
          },
          "indexingFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at indexing time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  When a fragment is deleted by passing `null` to its name, the corresponding embeddings are removed from documents.\n-  When a fragment is modified, the corresponding embeddings are regenerated if their rendered version changes.",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "searchFragments": {
            "type": [
              "object",
              "null"
            ],
            "description": "Template fragments that will be reassembled and sent to the remote embedder at search time.\n\n# Availability\n\n- This parameter is available for sources `rest`.\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {},
            "propertyNames": {
              "type": "string"
            }
          },
          "request": {
            "description": "Template request to send to the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "response": {
            "description": "Template response indicating how to find the embeddings in the response from the remote embedder.\n\n# Mandatory\n\n- This parameter is mandatory for source `rest`\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter always regenerates embeddings"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "description": "Additional headers to send to the remote embedder.\n\n# Availability\n\n- This parameter is available for source `rest`\n\n#  Reindexing\n\n-  Changing the value of this parameter never regenerates embeddings",
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            }
          }
        },
        "additionalProperties": false
      },
      "SummarizedTaskView": {
        "type": "object",
        "description": "A summarized view of a task, returned when a task is enqueued",
        "required": [
          "taskUid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "taskUid": {
            "type": "integer",
            "format": "u-int32",
            "description": "Unique sequential identifier of the task",
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ],
            "description": "Unique identifier of the targeted index. Null for global tasks"
          },
          "status": {
            "$ref": "#/components/schemas/Status",
            "description": "Status of the task. Possible values are enqueued, processing,\nsucceeded, failed, and canceled"
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "Type of operation performed by the task"
          },
          "enqueuedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Date and time when the task was enqueued"
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ],
            "description": "Custom metadata string that was attached to this task when it was\ncreated. This can be used to associate tasks with external systems or\nadd application-specific information."
          }
        }
      },
      "SwapIndexesPayload": {
        "type": "object",
        "description": "Request body for swapping two indexes",
        "required": [
          "indexes",
          "rename"
        ],
        "properties": {
          "indexes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IndexUid"
            },
            "description": "Array of the two index UIDs to be swapped"
          },
          "rename": {
            "type": "boolean",
            "description": "If true, rename the first index to the second instead of swapping"
          }
        }
      },
      "TaskView": {
        "type": "object",
        "description": "Represents the current state and details of an asynchronous task.\n\nTasks are created when you perform operations like adding documents,\nupdating settings, or creating indexes. Use this view to monitor task\nprogress and check for errors.",
        "required": [
          "uid",
          "status",
          "type",
          "enqueuedAt"
        ],
        "properties": {
          "uid": {
            "type": "integer",
            "format": "u-int32",
            "description": "The unique sequential identifier assigned to this task. Task UIDs are\nassigned in order of creation and can be used to retrieve specific\ntask information or track task dependencies.",
            "example": 4312,
            "minimum": 0
          },
          "batchUid": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "The unique identifier of the batch that processed this task. Multiple\ntasks may share the same batch UID if they were processed together\nfor efficiency. This is `null` for tasks that haven't been processed.",
            "example": 12,
            "minimum": 0
          },
          "indexUid": {
            "type": [
              "string",
              "null"
            ],
            "description": "The unique identifier of the index this task operates on. This is\n`null` for global tasks like `dumpCreation` or `taskDeletion` that\ndon't target a specific index."
          },
          "status": {
            "$ref": "#/components/schemas/Status",
            "description": "The current processing status of the task. Possible values are:\n`enqueued` (waiting), `processing` (executing), `succeeded`,\n`failed`, or `canceled`."
          },
          "type": {
            "$ref": "#/components/schemas/Kind",
            "description": "The type of operation this task performs. Examples include\n`documentAdditionOrUpdate`, `documentDeletion`, `settingsUpdate`,\n`indexCreation`, `indexDeletion`, `dumpCreation`, etc."
          },
          "canceledBy": {
            "type": [
              "integer",
              "null"
            ],
            "format": "u-int32",
            "description": "If this task was canceled, this field contains the UID of the\n`taskCancelation` task that canceled it. This is `null` for tasks\nthat were not canceled.",
            "example": 4326,
            "minimum": 0
          },
          "details": {
            "type": [
              "object",
              "null"
            ],
            "description": "Contains type-specific information about the task, such as the number\nof documents processed, settings that were applied, or filters that\nwere used. The structure varies depending on the task type."
          },
          "error": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/ResponseError",
                "description": "If the task failed, this field contains detailed error information\nincluding an error message, error code, error type, and a link to\ndocumentation. This is `null` for tasks that succeeded or are still\nprocessing."
              }
            ]
          },
          "duration": {
            "type": [
              "string",
              "null"
            ],
            "description": "The total time spent processing this task, formatted as an ISO-8601\nduration (e.g., `PT0.5S` for 0.5 seconds). This is `null` for tasks\nthat haven't finished processing yet.",
            "example": null
          },
          "enqueuedAt": {
            "type": "string",
            "description": "The timestamp when this task was added to the queue, formatted as an\nRFC 3339 date-time string. All tasks have an enqueued timestamp as\nit's set when the task is created.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "startedAt": {
            "type": "string",
            "description": "The timestamp when Meilisearch began processing this task, formatted\nas an RFC 3339 date-time string. This is `null` for tasks that are\nstill in the queue waiting to be processed.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "finishedAt": {
            "type": "string",
            "description": "The timestamp when this task finished processing (whether successfully\nor with an error), formatted as an RFC 3339 date-time string. This is\n`null` for tasks that haven't finished yet.",
            "example": "2024-08-08_14:12:09.393Z"
          },
          "network": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DbTaskNetwork",
                "description": "Network topology information for distributed deployments. Contains\ndetails about which nodes are involved in processing this task. This\nis only present when running Meilisearch in a distributed config."
              }
            ]
          },
          "customMetadata": {
            "type": [
              "string",
              "null"
            ],
            "description": "Custom metadata string that was attached to this task when it was\ncreated. This can be used to associate tasks with external systems,\ntrack task origins, or add any application-specific information."
          }
        }
      },
      "TypoSettings": {
        "type": "object",
        "description": "Configuration for typo tolerance in search queries.\n\nTypo tolerance allows Meilisearch to match documents even when search\nterms contain spelling mistakes.",
        "properties": {
          "enabled": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "When `true`, enables typo tolerance for search queries. When `false`,\nonly exact matches are returned. Defaults to `true`.",
            "example": true
          },
          "minWordSizeForTypos": {
            "oneOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/MinWordSizeTyposSetting",
                "description": "Configures the minimum word length before typos are allowed. Contains\n`oneTypo` (min length for 1 typo) and `twoTypos` (min length for 2\ntypos) settings."
              }
            ]
          },
          "disableOnWords": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "A list of words for which typo tolerance should be disabled. Use this\nfor brand names, technical terms, or other words that must be matched\nexactly. Example: `[\"iPhone\", \"macOS\"]`.",
            "example": [
              "iPhone",
              "phone"
            ],
            "uniqueItems": true
          },
          "disableOnAttributes": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "description": "A list of attributes for which typo tolerance should be disabled.\nSearches in these attributes will only return exact matches. Useful\nfor fields like product codes or IDs.",
            "example": [
              "uuid",
              "url"
            ],
            "uniqueItems": true
          },
          "disableOnNumbers": {
            "type": [
              "boolean",
              "null"
            ],
            "description": "When `true`, disables typo tolerance on numeric tokens. This prevents\nnumbers like `123` from matching `132`. Defaults to `false`.",
            "example": true
          }
        },
        "additionalProperties": false
      },
      "Unchecked": {
        "default": null
      },
      "UpdateIndexRequest": {
        "type": "object",
        "description": "Request body for updating an existing index",
        "properties": {
          "primaryKey": {
            "type": [
              "string",
              "null"
            ],
            "description": "New primary key of the index"
          },
          "uid": {
            "type": [
              "string",
              "null"
            ],
            "description": "New uid for the index (for renaming)"
          }
        }
      },
      "UpdateStderrLogs": {
        "type": "object",
        "description": "Request body for updating stderr log configuration",
        "required": [
          "target"
        ],
        "properties": {
          "target": {
            "type": "string",
            "description": "Log targets to filter. Format: code_part=log_level (e.g.,\nmilli=trace,actix_web=off)",
            "default": "info",
            "example": "milli=trace,index_scheduler,actix_web=off"
          }
        }
      },
      "Vec": {
        "type": "array",
        "items": {
          "type": "number",
          "format": "float"
        }
      },
      "VectorStoreBackend": {
        "type": "string",
        "enum": [
          "stable",
          "experimental"
        ]
      },
      "VersionResponse": {
        "type": "object",
        "required": [
          "commitSha",
          "commitDate",
          "pkgVersion"
        ],
        "properties": {
          "commitSha": {
            "type": "string",
            "description": "The commit used to compile this build of Meilisearch."
          },
          "commitDate": {
            "type": "string",
            "description": "The date of this build."
          },
          "pkgVersion": {
            "type": "string",
            "description": "The version of Meilisearch."
          }
        }
      },
      "WebhookResults": {
        "type": "object",
        "description": "Response containing a list of all registered webhooks",
        "required": [
          "results"
        ],
        "properties": {
          "results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WebhookWithMetadataRedactedAuthorization"
            },
            "description": "Array of all webhooks configured in this Meilisearch instance. Each\nwebhook includes its UUID, URL, headers (with authorization values\nredacted), and editability status."
          }
        }
      },
      "WebhookSettings": {
        "type": "object",
        "description": "Configuration for a webhook endpoint",
        "properties": {
          "url": {
            "type": [
              "string",
              "null"
            ],
            "description": "URL endpoint to call when tasks complete",
            "example": "https://your.site/on-tasks-completed"
          },
          "headers": {
            "type": [
              "object",
              "null"
            ],
            "description": "HTTP headers to include in webhook requests",
            "additionalProperties": {
              "type": "string"
            },
            "propertyNames": {
              "type": "string"
            },
            "example": {
              "Authorization": "Bearer a-secret-token"
            }
          }
        }
      },
      "WebhookWithMetadataRedactedAuthorization": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WebhookSettings",
            "description": "Webhook settings"
          },
          {
            "type": "object",
            "required": [
              "uuid",
              "isEditable"
            ],
            "properties": {
              "uuid": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier of the webhook"
              },
              "isEditable": {
                "type": "boolean",
                "description": "Whether the webhook can be edited"
              }
            }
          }
        ],
        "description": "A webhook with metadata and redacted authorization headers"
      },
      "u32": {
        "type": "integer",
        "format": "u-int32",
        "minimum": 0
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "Uuidv4, string or JWT",
        "description": "An API key is a token that you provide when making API calls. Read more about [how to secure your project](https://www.meilisearch.com/docs/learn/security/basic_security).\n\nInclude the API key to the `Authorization` header, for instance:\n`Authorization: Bearer 6436fc5237b0d6e0d64253fbaac21d135012ecf1`.\n\nIf you use a SDK, ensure you instantiate the client with the API key, for instance with JS SDK:\n`const client = new MeiliSearch({ host: 'https://your-domain.com', apiKey: '6436fc5237b0d6e0d64253fbaac21d135012ecf1' })`"
      }
    }
  },
  "tags": [
    {
      "name": "Stats",
      "description": "Stats gives extended information and metrics about indexes and the Meilisearch database."
    },
    {
      "name": "Health",
      "description": "The health check endpoint enables you to periodically test the health of your Meilisearch instance."
    },
    {
      "name": "Version",
      "description": "Returns the version of the running Meilisearch instance."
    },
    {
      "name": "Backups",
      "description": "Meilisearch offers two types of backups: snapshots and dumps. Snapshots are mainly intended as a safeguard, while dumps are useful when migrating Meilisearch."
    },
    {
      "name": "Tasks",
      "description": "The tasks route gives information about the progress of the [asynchronous operations](https://docs.meilisearch.com/learn/advanced/asynchronous_operations.html)."
    },
    {
      "name": "Batches",
      "description": "The /batches route gives information about the progress of batches of asynchronous operations."
    },
    {
      "name": "Indexes",
      "description": "An index is an entity that gathers a set of [documents](https://www.meilisearch.com/docs/learn/getting_started/documents) with its own [settings](https://www.meilisearch.com/docs/reference/api/settings). Learn more about indexes."
    },
    {
      "name": "Documents",
      "description": "Documents are objects composed of fields that can store any type of data. Each field contains an attribute and its associated value. Documents are stored inside [indexes](https://www.meilisearch.com/docs/learn/getting_started/indexes)."
    },
    {
      "name": "Facet Search",
      "description": "The `/facet-search` route allows you to search for facet values. Facet search supports prefix search and typo tolerance. The returned hits are sorted lexicographically in ascending order. You can configure how facets are sorted using the sortFacetValuesBy property of the faceting index settings."
    },
    {
      "name": "Similar documents",
      "description": "The /similar route uses AI-powered search to return a number of documents similar to a target document.\n\nMeilisearch exposes two routes for retrieving similar documents: POST and GET. In the majority of cases, POST will offer better performance and ease of use."
    },
    {
      "name": "Settings",
      "description": "Use the /settings route to customize search settings for a given index. You can either modify all index settings at once using the update settings endpoint, or use a child route to configure a single setting."
    },
    {
      "name": "Search",
      "description": "Meilisearch exposes two routes to perform searches:\n\n- A POST route: this is the preferred route when using API authentication, as it allows [preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) caching and better performance.\n- A GET route: the usage of this route is discouraged, unless you have good reason to do otherwise (specific caching abilities for example)"
    },
    {
      "name": "Keys",
      "description": "Manage API `keys` for a Meilisearch instance. Each key has a given set of permissions.\nYou must have the master key or the default admin key to access the keys route. More information about the keys and their rights.\nAccessing any route under `/keys` without having set a master key will result in an error."
    },
    {
      "name": "Logs",
      "description": "Everything about retrieving or customizing logs.\nCurrently [experimental](https://www.meilisearch.com/docs/learn/experimental/overview)."
    },
    {
      "name": "Multi-search",
      "description": "The `/multi-search` route allows you to perform multiple search queries on one or more indexes by bundling them into a single HTTP request. Multi-search is also known as federated search."
    },
    {
      "name": "Experimental features",
      "description": "The `/experimental-features` route allows you to activate or deactivate some of Meilisearch's experimental features.\n\nThis route is **synchronous**. This means that no task object will be returned, and any activated or deactivated features will be made available or unavailable immediately."
    },
    {
      "name": "Network",
      "description": "The `/network` route allows you to describe the topology of a network of Meilisearch instances.\n\nThis route is **synchronous**. This means that no task object will be returned, and any change to the network will be made available immediately."
    },
    {
      "name": "Webhooks",
      "description": "The `/webhooks` route allows you to register endpoints to be called once tasks are processed."
    }
  ]
}